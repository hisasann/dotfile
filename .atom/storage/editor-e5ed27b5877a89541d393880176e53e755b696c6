{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":22,"width":1440,"height":874},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/hisamatsu/_/dev/mcdonald-s-unity1","buffers":[{"text":"ï»¿using UnityEngine;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class BaseCharacterController : MonoBehaviour\n{\n\tpublic float acceleRate = 2.0f;\n\tpublic bool  isWalkingRangeXLimit = true;\n\tpublic float rangeXMin = -3.0f;\n\tpublic float rangeXMax = 3.0f;\n\tpublic float walkSpeed = 5.0f;\n\tpublic float gravity = 10.0f;\n\tpublic float jump = 15.0f;\n\tprotected Vector3 moveDirection;\n\tprotected Vector3 origLocalScale;\n\tprotected CharacterController CC;\n\tprotected TextureMotor TM;\n\tprotected float moveX = 1;\n\tprotected float jumpX = 2;\n\tprotected bool isAction = false;\n\tprotected List<float> moveXProbability;\n\tprotected List<float> jumpXProbability;\n\tprotected float accele = 1.0f;\n\tprotected bool isAnimateStart = false;\n\tprotected int actionCount = 0;\n\tprotected float startZ;\n\tprotected float stopTimer;\n\tprotected float isLeaveCount;\n\tprotected bool isLeave = false;\n\t\n\tvoid Start() {\n\t}\n\n\tprotected void setupMoveX ()\n\t{\n\t\tfloat mg = CC.velocity.magnitude;\n\t\tif (mg > 0.0f) {\n\t\t\tstopTimer = 0;\n\t\t} else {\n\t\t\tstopTimer += Time.deltaTime;\n\t\t}\n\t\tif (stopTimer > Random.Range (3, 4)) {\n\t\t\tisAction = true;\n\t\t\tisAnimateStart = true;\n\t\t\tstopTimer = 0;\n\t\t\tmoveX = moveX == 1 ? -1 : 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (actionCount > 20) {\n\t\t\tmoveX = moveXProbability [Random.Range (0, moveXProbability.Count)];\n\t\t\tactionCount = 0;\n\t\t}\n\t}\n\n\tprotected Vector3 ApplyColliderResult (Vector3 direction)\n\t{\n\t\treturn direction * this.accele;\n\t}\n\t\n\tprotected void DestroyObject ()\n\t{\n\t\tforeach (Transform t in transform) {\n\t\t\tDestroy (t.gameObject.renderer.material);\n\t\t\tDestroy (t.gameObject);\n\t\t}\n\t\tDestroy (gameObject.renderer.material);\n\t\tDestroy (gameObject);\n\t}\n\t\n\tpublic void Jump ()\n\t{\n\t\tjumpXProbability = new List<float> ();\n\t\tjumpXProbability.Add (2);\n\t\tjumpXProbability.Add (-2);\n\t\tjumpX = jumpXProbability [Random.Range (0, jumpXProbability.Count)];\n\t\tmoveDirection.x = jumpX;\n\t\tmoveDirection.y = jump + 3;\n\t\tjumpXProbability = null;\n\t}\n\n\tvoid OnDrawGizmos ()\n\t{\n\t\tGizmos.color = Color.blue;\n\t\tGizmos.DrawLine (transform.position, transform.position + moveDirection * 0.6f);\n\t\tGizmos.color = Color.green;\n\t\tGizmos.DrawSphere (transform.position + moveDirection * 0.6f, 1.2f);\n\t\t\t\n\t}\n}\n","markers":{"markers":{"1":{"id":1,"range":[[2,0],[2,33]],"tailed":true,"reversed":true,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":139,"autoscroll":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/hisamatsu/_/dev/mcdonald-s-unity1/Assets/Scripts/character/BaseCharacterController.cs","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"165be8f0a0138a1633fd7bf09d1a59f40547e449","deserializer":"TextBuffer"},{"text":"// Copyright (c) 2011 Bob Berkebile (pixelplacment)\n// Please direct any bugs/comments/suggestions to http://pixelplacement.com\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/*\nTERMS OF USE - EASING EQUATIONS\nOpen source under the BSD License.\nCopyright (c)2001 Robert Penner\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#region Namespaces\nusing System;\nusing System.Collections;\nusing System.Reflection;\nusing UnityEngine;\n#endregion\n\n/// <summary>\n/// <para>Version: 2.0.45</para>\t \n/// <para>Author: Bob Berkebile (http://pixelplacement.com)</para>\n/// <para>Support: http://itween.pixelplacement.com</para>\n/// </summary>\npublic class iTween : MonoBehaviour{\n\t\n\t#region Variables\n\t\n\t//repository of all living iTweens:\n\tpublic static ArrayList tweens = new ArrayList();\n\t\n\t//camera fade object:\n\tprivate static GameObject cameraFade;\n\t\n\t//status members (made public for visual troubleshooting in the inspector):\n\tpublic string id, type, method;\n\tpublic iTween.EaseType easeType;\n\tpublic float time, delay;\n\tpublic LoopType loopType;\n\tpublic bool isRunning,isPaused;\n\t/* GFX47 MOD START */\n\tpublic string _name;\n\t/* GFX47 MOD END */\n\t\t\n\t//private members:\n \tprivate float runningTime, percentage;\n\tprivate float delayStarted; //probably not neccesary that this be protected but it shuts Unity's compiler up about this being \"never used\"\n\tprivate bool kinematic, isLocal, loop, reverse, wasPaused, physics;\n\tprivate Hashtable tweenArguments;\n\tprivate Space space;\n\tprivate delegate float EasingFunction(float start, float end, float value);\n\tprivate delegate void ApplyTween();\n\tprivate EasingFunction ease;\n\tprivate ApplyTween apply;\n\tprivate AudioSource audioSource;\n\tprivate Vector3[] vector3s;\n\tprivate Vector2[] vector2s;\n\tprivate Color[,] colors;\n\tprivate float[] floats;\n\tprivate Rect[] rects;\n\tprivate CRSpline path;\n\tprivate Vector3 preUpdate;\n\tprivate Vector3 postUpdate;\n\tprivate NamedValueColor namedcolorvalue;\n\n    private float lastRealTime; // Added by PressPlay\n    private bool useRealTime; // Added by PressPlay\n\n\t/// <summary>\n\t/// The type of easing to use based on Robert Penner's open source easing equations (http://www.robertpenner.com/easing_terms_of_use.html).\n\t/// </summary>\n\tpublic enum EaseType{\n\t\teaseInQuad,\n\t\teaseOutQuad,\n\t\teaseInOutQuad,\n\t\teaseInCubic,\n\t\teaseOutCubic,\n\t\teaseInOutCubic,\n\t\teaseInQuart,\n\t\teaseOutQuart,\n\t\teaseInOutQuart,\n\t\teaseInQuint,\n\t\teaseOutQuint,\n\t\teaseInOutQuint,\n\t\teaseInSine,\n\t\teaseOutSine,\n\t\teaseInOutSine,\n\t\teaseInExpo,\n\t\teaseOutExpo,\n\t\teaseInOutExpo,\n\t\teaseInCirc,\n\t\teaseOutCirc,\n\t\teaseInOutCirc,\n\t\tlinear,\n\t\tspring,\n\t\t/* GFX47 MOD START */\n\t\t//bounce,\n\t\teaseInBounce,\n\t\teaseOutBounce,\n\t\teaseInOutBounce,\n\t\t/* GFX47 MOD END */\n\t\teaseInBack,\n\t\teaseOutBack,\n\t\teaseInOutBack,\n\t\t/* GFX47 MOD START */\n\t\t//elastic,\n\t\teaseInElastic,\n\t\teaseOutElastic,\n\t\teaseInOutElastic,\n\t\t/* GFX47 MOD END */\n\t\tpunch\n\t}\n\t\n\t/// <summary>\n\t/// The type of loop (if any) to use.  \n\t/// </summary>\n\tpublic enum LoopType{\n\t\t/// <summary>\n\t\t/// Do not loop.\n\t\t/// </summary>\n\t\tnone,\n\t\t/// <summary>\n\t\t/// Rewind and replay.\n\t\t/// </summary>\n\t\tloop,\n\t\t/// <summary>\n\t\t/// Ping pong the animation back and forth.\n\t\t/// </summary>\n\t\tpingPong\n\t}\n\t\n\t/// <summary>\n\t/// Many shaders use more than one color. Use can have iTween's Color methods operate on them by name.   \n\t/// </summary>\n\tpublic enum NamedValueColor{\n\t\t/// <summary>\n\t\t/// The main color of a material. Used by default and not required for Color methods to work in iTween.\n\t\t/// </summary>\n\t\t_Color,\n\t\t/// <summary>\n\t\t/// The specular color of a material (used in specular/glossy/vertexlit shaders).\n\t\t/// </summary>\n\t\t_SpecColor,\n\t\t/// <summary>\n\t\t/// The emissive color of a material (used in vertexlit shaders).\n\t\t/// </summary>\n\t\t_Emission,\n\t\t/// <summary>\n\t\t/// The reflection color of the material (used in reflective shaders).\n\t\t/// </summary>\n\t\t_ReflectColor\n\t}\n\t\t\t\t\n\t#endregion\n\t\n\t#region Defaults\n\t\n\t/// <summary>\n\t/// A collection of baseline presets that iTween needs and utilizes if certain parameters are not provided. \n\t/// </summary>\n\tpublic static class Defaults{\n\t\t//general defaults:\n\t\tpublic static float time = 1f;\n\t\tpublic static float delay = 0f;\t\n\t\tpublic static NamedValueColor namedColorValue = NamedValueColor._Color;\n\t\tpublic static LoopType loopType = LoopType.none;\n\t\tpublic static EaseType easeType = iTween.EaseType.easeOutExpo;\n\t\tpublic static float lookSpeed = 3f;\n\t\tpublic static bool isLocal = false;\n\t\tpublic static Space space = Space.Self;\n\t\tpublic static bool orientToPath = false;\n\t\tpublic static Color color = Color.white;\n\t\t//update defaults:\n\t\tpublic static float updateTimePercentage = .05f;\n\t\tpublic static float updateTime = 1f*updateTimePercentage;\n\t\t//cameraFade defaults:\n\t\tpublic static int cameraFadeDepth = 999999;\n\t\t//path look ahead amount:\n\t\tpublic static float lookAhead = .05f;\n        public static bool useRealTime = false; // Added by PressPlay\n\t\t//look direction:\n\t\tpublic static Vector3 up = Vector3.up;\n\t}\n\t\n\t#endregion\n\t\n\t#region #1 Static Registers\n\n\t/// <summary>\n\t/// Sets up a GameObject to avoid hiccups when an initial iTween is added. It's advisable to run this on every object you intend to run iTween on in its Start or Awake.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target to be initialized for iTween.\n\t/// </param>\n\tpublic static void Init(GameObject target){\n\t\tMoveBy(target,Vector3.zero,0);\n\t}\n\t\n\t/// <summary>\n\t/// Instantly changes the amount(transparency) of a camera fade and then returns it back over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for how transparent the Texture2D that the camera fade uses is.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void CameraFadeFrom(float amount, float time){\n\t\tif(cameraFade){\n\t\t\tCameraFadeFrom(Hash(\"amount\",amount,\"time\",time));\n\t\t}else{\n\t\t\tDebug.LogError(\"iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.\");\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Instantly changes the amount(transparency) of a camera fade and then returns it back over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for how transparent the Texture2D that the camera fade uses is.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void CameraFadeFrom(Hashtable args){\t\t\n\t\t//establish iTween:\n\t\tif(cameraFade){\n\t\t\tColorFrom(cameraFade,args);\n\t\t}else{\n\t\t\tDebug.LogError(\"iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.\");\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Changes the amount(transparency) of a camera fade over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for how transparent the Texture2D that the camera fade uses is.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void CameraFadeTo(float amount, float time){\n\t\tif(cameraFade){\n\t\t\tCameraFadeTo(Hash(\"amount\",amount,\"time\",time));\n\t\t}else{\n\t\t\tDebug.LogError(\"iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.\");\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Changes the amount(transparency) of a camera fade over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for how transparent the Texture2D that the camera fade uses is.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void CameraFadeTo(Hashtable args){\n\t\t/*\n\t\tCameraFadeAdd(Defaults.cameraFadeDepth);\n\t\t\n\t\t//rescale cameraFade just in case screen size has changed to ensure it takes up the full screen:\n\t\tcameraFade.guiTexture.pixelInset=new Rect(0,0,Screen.width,Screen.height);\n\t\t*/\n\t\n\t\tif(cameraFade){\n\t\t\t//establish iTween:\n\t\t\tColorTo(cameraFade,args);\n\t\t}else{\n\t\t\tDebug.LogError(\"iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.\");\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Returns a value to an 'oncallback' method interpolated between the supplied 'from' and 'to' values for application as desired.  Requires an 'onupdate' callback that accepts the same type as the supplied 'from' and 'to' properties.\n\t/// </summary>\n\t/// <param name=\"from\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> or <see cref=\"Vector3\"/> or <see cref=\"Vector2\"/> or <see cref=\"Color\"/> or <see cref=\"Rect\"/> for the starting value.\n\t/// </param> \n\t/// <param name=\"to\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> or <see cref=\"Vector3\"/> or <see cref=\"Vector2\"/> or <see cref=\"Color\"/> or <see cref=\"Rect\"/> for the ending value.\n\t/// </param> \n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed (only works with Vector2, Vector3, and Floats)\n\t/// </param>\t\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void ValueTo(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\tif (!args.Contains(\"onupdate\") || !args.Contains(\"from\") || !args.Contains(\"to\")) {\n\t\t\tDebug.LogError(\"iTween Error: ValueTo() requires an 'onupdate' callback function and a 'from' and 'to' property.  The supplied 'onupdate' callback must accept a single argument that is the same type as the supplied 'from' and 'to' properties!\");\n\t\t\treturn;\n\t\t}else{\n\t\t\t//establish iTween:\n\t\t\targs[\"type\"]=\"value\";\n\t\t\t\n\t\t\tif (args[\"from\"].GetType() == typeof(Vector2)) {\n\t\t\t\targs[\"method\"]=\"vector2\";\n\t\t\t}else if (args[\"from\"].GetType() == typeof(Vector3)) {\n\t\t\t\targs[\"method\"]=\"vector3\";\n\t\t\t}else if (args[\"from\"].GetType() == typeof(Rect)) {\n\t\t\t\targs[\"method\"]=\"rect\";\n\t\t\t}else if (args[\"from\"].GetType() == typeof(Single)) {\n\t\t\t\targs[\"method\"]=\"float\";\n\t\t\t}else if (args[\"from\"].GetType() == typeof(Color)) {\n\t\t\t\targs[\"method\"]=\"color\";\n\t\t\t}else{\n\t\t\t\tDebug.LogError(\"iTween Error: ValueTo() only works with interpolating Vector3s, Vector2s, floats, ints, Rects and Colors!\");\n\t\t\t\treturn;\t\n\t\t\t}\n\t\t\t\n\t\t\t//set a default easeType of linear if none is supplied since eased color interpolation is nearly unrecognizable:\n\t\t\tif (!args.Contains(\"easetype\")) {\n\t\t\t\targs.Add(\"easetype\",EaseType.linear);\n\t\t\t}\n\t\t\t\n\t\t\tLaunch(target,args);\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Changes a GameObject's alpha value instantly then returns it to the provided alpha over time with MINIMUM customization options.  If a GUIText or GUITexture component is attached, it will become the target of the animation. Identical to using ColorFrom and using the \"a\" parameter. \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"alpha\">\n\t/// A <see cref=\"System.Single\"/> for the final alpha value of the animation.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void FadeFrom(GameObject target, float alpha, float time){\n\t\tFadeFrom(target,Hash(\"alpha\",alpha,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Changes a GameObject's alpha value instantly then returns it to the provided alpha over time with FULL customization options.  If a GUIText or GUITexture component is attached, it will become the target of the animation. Identical to using ColorFrom and using the \"a\" parameter.\n\t/// </summary>\n\t/// <param name=\"alpha\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the initial alpha value of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the initial alpha value of the animation.\n\t/// </param>\n\t/// <param name=\"includechildren\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not to include children of this GameObject. True by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void FadeFrom(GameObject target, Hashtable args){\t\n\t\tColorFrom(target,args);\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Changes a GameObject's alpha value over time with MINIMUM customization options.  If a GUIText or GUITexture component is attached, it will become the target of the animation. Identical to using ColorTo and using the \"a\" parameter.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"alpha\">\n\t/// A <see cref=\"System.Single\"/> for the final alpha value of the animation.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void FadeTo(GameObject target, float alpha, float time){\n\t\tFadeTo(target,Hash(\"alpha\",alpha,\"time\",time));\n\t}\t\n\n\t/// <summary>\n\t/// Changes a GameObject's alpha value over time with FULL customization options.  If a GUIText or GUITexture component is attached, it will become the target of the animation. Identical to using ColorTo and using the \"a\" parameter.\n\t/// </summary>\n\t/// <param name=\"alpha\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the final alpha value of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the final alpha value of the animation.\n\t/// </param>\n\t/// <param name=\"includechildren\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not to include children of this GameObject. True by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void FadeTo(GameObject target, Hashtable args){\n\t\tColorTo(target,args);\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Changes a GameObject's color values instantly then returns them to the provided properties over time with MINIMUM customization options.  If a GUIText or GUITexture component is attached, it will become the target of the animation.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/> to change the GameObject's color to.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ColorFrom(GameObject target, Color color, float time){\n\t\tColorFrom(target,Hash(\"color\",color,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Changes a GameObject's color values instantly then returns them to the provided properties over time with FULL customization options.  If a GUIText or GUITexture component is attached, it will become the target of the animation.\n\t/// </summary>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/> to change the GameObject's color to.\n\t/// </param>\n\t/// <param name=\"r\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the color red.\n\t/// </param>\n\t/// <param name=\"g\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the color green.\n\t/// </param>\n\t/// <param name=\"b\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the color green.\n\t/// </param>\n\t/// <param name=\"a\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the alpha.\n\t/// </param> \n\t/// <param name=\"namedcolorvalue\">\n\t/// A <see cref=\"NamedColorValue\"/> or <see cref=\"System.String\"/> for the individual setting of the alpha.\n\t/// </param> \n\t/// <param name=\"includechildren\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not to include children of this GameObject. True by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void ColorFrom(GameObject target, Hashtable args){\t\n\t\tColor fromColor = new Color();\n\t\tColor tempColor = new Color();\n\t\t\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//handle children:\n\t\tif(!args.Contains(\"includechildren\") || (bool)args[\"includechildren\"]){\n\t\t\tforeach(Transform child in target.transform){\n\t\t\t\tHashtable argsCopy = (Hashtable)args.Clone();\n\t\t\t\targsCopy[\"ischild\"]=true;\n\t\t\t\tColorFrom(child.gameObject,argsCopy);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//set a default easeType of linear if none is supplied since eased color interpolation is nearly unrecognizable:\n\t\tif (!args.Contains(\"easetype\")) {\n\t\t\targs.Add(\"easetype\",EaseType.linear);\n\t\t}\n\t\t\n\t\t//set tempColor and base fromColor:\n\t\tif(target.GetComponent(typeof(GUITexture))){\n\t\t\ttempColor=fromColor=target.guiTexture.color;\t\n\t\t}else if(target.GetComponent(typeof(GUIText))){\n\t\t\ttempColor=fromColor=target.guiText.material.color;\n\t\t}else if(target.renderer){\n\t\t\ttempColor=fromColor=target.renderer.material.color;\n\t\t}else if(target.light){\n\t\t\ttempColor=fromColor=target.light.color;\n\t\t}\n\t\t\n\t\t//set augmented fromColor:\n\t\tif(args.Contains(\"color\")){\n\t\t\tfromColor=(Color)args[\"color\"];\n\t\t}else{\n\t\t\tif (args.Contains(\"r\")) {\n\t\t\t\tfromColor.r=(float)args[\"r\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"g\")) {\n\t\t\t\tfromColor.g=(float)args[\"g\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"b\")) {\n\t\t\t\tfromColor.b=(float)args[\"b\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"a\")) {\n\t\t\t\tfromColor.a=(float)args[\"a\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//alpha or amount?\n\t\tif(args.Contains(\"amount\")){\n\t\t\tfromColor.a=(float)args[\"amount\"];\n\t\t\targs.Remove(\"amount\");\n\t\t}else if(args.Contains(\"alpha\")){\n\t\t\tfromColor.a=(float)args[\"alpha\"];\n\t\t\targs.Remove(\"alpha\");\n\t\t}\n\t\t\n\t\t//apply fromColor:\n\t\tif(target.GetComponent(typeof(GUITexture))){\n\t\t\ttarget.guiTexture.color=fromColor;\t\n\t\t}else if(target.GetComponent(typeof(GUIText))){\n\t\t\ttarget.guiText.material.color=fromColor;\n\t\t}else if(target.renderer){\n\t\t\ttarget.renderer.material.color=fromColor;\n\t\t}else if(target.light){\n\t\t\ttarget.light.color=fromColor;\n\t\t}\n\t\t\n\t\t//set new color arg:\n\t\targs[\"color\"]=tempColor;\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"color\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Changes a GameObject's color values over time with MINIMUM customization options.  If a GUIText or GUITexture component is attached, they will become the target of the animation.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/> to change the GameObject's color to.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ColorTo(GameObject target, Color color, float time){\n\t\tColorTo(target,Hash(\"color\",color,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Changes a GameObject's color values over time with FULL customization options.  If a GUIText or GUITexture component is attached, they will become the target of the animation.\n\t/// </summary>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/> to change the GameObject's color to.\n\t/// </param>\n\t/// <param name=\"r\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the color red.\n\t/// </param>\n\t/// <param name=\"g\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the color green.\n\t/// </param>\n\t/// <param name=\"b\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the color green.\n\t/// </param>\n\t/// <param name=\"a\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the alpha.\n\t/// </param> \n\t/// <param name=\"namedcolorvalue\">\n\t/// A <see cref=\"NamedColorValue\"/> or <see cref=\"System.String\"/> for the individual setting of the alpha.\n\t/// </param> \n\t/// <param name=\"includechildren\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not to include children of this GameObject. True by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void ColorTo(GameObject target, Hashtable args){\t\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//handle children:\n\t\tif(!args.Contains(\"includechildren\") || (bool)args[\"includechildren\"]){\n\t\t\tforeach(Transform child in target.transform){\n\t\t\t\tHashtable argsCopy = (Hashtable)args.Clone();\n\t\t\t\targsCopy[\"ischild\"]=true;\n\t\t\t\tColorTo(child.gameObject,argsCopy);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//set a default easeType of linear if none is supplied since eased color interpolation is nearly unrecognizable:\n\t\tif (!args.Contains(\"easetype\")) {\n\t\t\targs.Add(\"easetype\",EaseType.linear);\n\t\t}\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"color\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\n\t}\t\n\t\n\t/// <summary>\n\t/// Instantly changes an AudioSource's volume and pitch then returns it to it's starting volume and pitch over time with MINIMUM customization options. Default AudioSource attached to GameObject will be used (if one exists) if not supplied.\n\t/// </summary>\n\t/// <param name=\"target\"> \n\t/// A <see cref=\"GameObject\"/> to be the target of the animation which holds the AudioSource to be changed.\n\t/// </param>\n\t/// <param name=\"volume\"> for the target level of volume.\n\t/// A <see cref=\"System.Single\"/>\n\t/// </param>\n\t/// <param name=\"pitch\"> for the target pitch.\n\t/// A <see cref=\"System.Single\"/>\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void AudioFrom(GameObject target, float volume, float pitch, float time){\n\t\tAudioFrom(target,Hash(\"volume\",volume,\"pitch\",pitch,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Instantly changes an AudioSource's volume and pitch then returns it to it's starting volume and pitch over time with FULL customization options. Default AudioSource attached to GameObject will be used (if one exists) if not supplied. \n\t/// </summary>\n\t/// <param name=\"audiosource\">\n\t/// A <see cref=\"AudioSource\"/> for which AudioSource to use.\n\t/// </param> \n\t/// <param name=\"volume\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the target level of volume.\n\t/// </param>\n\t/// <param name=\"pitch\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the target pitch.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void AudioFrom(GameObject target, Hashtable args){\n\t\tVector2 tempAudioProperties;\n\t\tVector2 fromAudioProperties;\n\t\tAudioSource tempAudioSource;\n\t\t\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//set tempAudioSource:\n\t\tif(args.Contains(\"audiosource\")){\n\t\t\ttempAudioSource=(AudioSource)args[\"audiosource\"];\n\t\t}else{\n\t\t\tif(target.GetComponent(typeof(AudioSource))){\n\t\t\t\ttempAudioSource=target.audio;\n\t\t\t}else{\n\t\t\t\t//throw error if no AudioSource is available:\n\t\t\t\tDebug.LogError(\"iTween Error: AudioFrom requires an AudioSource.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\t\t\t\n\t\t\n\t\t//set tempAudioProperties:\n\t\ttempAudioProperties.x=fromAudioProperties.x=tempAudioSource.volume;\n\t\ttempAudioProperties.y=fromAudioProperties.y=tempAudioSource.pitch;\n\t\t\n\t\t//set augmented fromAudioProperties:\n\t\tif(args.Contains(\"volume\")){\n\t\t\tfromAudioProperties.x=(float)args[\"volume\"];\n\t\t}\n\t\tif(args.Contains(\"pitch\")){\n\t\t\tfromAudioProperties.y=(float)args[\"pitch\"];\n\t\t}\n\t\t\n\t\t//apply fromAudioProperties:\n\t\ttempAudioSource.volume=fromAudioProperties.x;\n\t\ttempAudioSource.pitch=fromAudioProperties.y;\n\t\t\t\t\n\t\t//set new volume and pitch args:\n\t\targs[\"volume\"]=tempAudioProperties.x;\n\t\targs[\"pitch\"]=tempAudioProperties.y;\n\t\t\n\t\t//set a default easeType of linear if none is supplied since eased audio interpolation is nearly unrecognizable:\n\t\tif (!args.Contains(\"easetype\")) {\n\t\t\targs.Add(\"easetype\",EaseType.linear);\n\t\t}\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"audio\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\t\t\t\n\t}\t\t\n\n\t/// <summary>\n\t/// Fades volume and pitch of an AudioSource with MINIMUM customization options.  Default AudioSource attached to GameObject will be used (if one exists) if not supplied. \n\t/// </summary>\n\t/// <param name=\"target\"> \n\t/// A <see cref=\"GameObject\"/> to be the target of the animation which holds the AudioSource to be changed.\n\t/// </param>\n\t/// <param name=\"volume\"> for the target level of volume.\n\t/// A <see cref=\"System.Single\"/>\n\t/// </param>\n\t/// <param name=\"pitch\"> for the target pitch.\n\t/// A <see cref=\"System.Single\"/>\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void AudioTo(GameObject target, float volume, float pitch, float time){\n\t\tAudioTo(target,Hash(\"volume\",volume,\"pitch\",pitch,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Fades volume and pitch of an AudioSource with FULL customization options.  Default AudioSource attached to GameObject will be used (if one exists) if not supplied. \n\t/// </summary>\n\t/// <param name=\"audiosource\">\n\t/// A <see cref=\"AudioSource\"/> for which AudioSource to use.\n\t/// </param> \n\t/// <param name=\"volume\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the target level of volume.\n\t/// </param>\n\t/// <param name=\"pitch\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the target pitch.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void AudioTo(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//set a default easeType of linear if none is supplied since eased audio interpolation is nearly unrecognizable:\n\t\tif (!args.Contains(\"easetype\")) {\n\t\t\targs.Add(\"easetype\",EaseType.linear);\n\t\t}\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"audio\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\t\t\t\n\t}\t\n\t\n\t/// <summary>\n\t/// Plays an AudioClip once based on supplied volume and pitch and following any delay with MINIMUM customization options. AudioSource is optional as iTween will provide one.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation which holds the AudioSource to be utilized.\n\t/// </param>\n\t/// <param name=\"audioclip\">\n\t/// A <see cref=\"AudioClip\"/> for a reference to the AudioClip to be played.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the action will wait before beginning.\n\t/// </param>\n\tpublic static void Stab(GameObject target, AudioClip audioclip, float delay){\n\t\tStab(target,Hash(\"audioclip\",audioclip,\"delay\",delay));\n\t}\n\t\n\t/// <summary>\n\t/// Plays an AudioClip once based on supplied volume and pitch and following any delay with FULL customization options. AudioSource is optional as iTween will provide one.\n\t/// </summary>\n\t/// <param name=\"audioclip\">\n\t/// A <see cref=\"AudioClip\"/> for a reference to the AudioClip to be played.\n\t/// </param> \n\t/// <param name=\"audiosource\">\n\t/// A <see cref=\"AudioSource\"/> for which AudioSource to use\n\t/// </param> \n\t/// <param name=\"volume\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the target level of volume.\n\t/// </param>\n\t/// <param name=\"pitch\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the target pitch.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the action will wait before beginning.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void Stab(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"stab\";\n\t\tLaunch(target,args);\t\t\t\n\t}\n\t\n\t/// <summary>\n\t/// Instantly rotates a GameObject to look at the supplied Vector3 then returns it to it's starting rotation over time with MINIMUM customization options. \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Vector3\"/> to be the Vector3 that the target will look towards.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void LookFrom(GameObject target, Vector3 looktarget, float time){\n\t\tLookFrom(target,Hash(\"looktarget\",looktarget,\"time\",time));\n\t}\t\n\t\n\t/// <summary>\n\t/// Instantly rotates a GameObject to look at a supplied Transform or Vector3 then returns it to it's starting rotation over time with FULL customization options. \n\t/// </summary>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"axis\">\n\t/// A <see cref=\"System.String\"/>. Restricts rotation to the supplied axis only.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void LookFrom(GameObject target, Hashtable args){\n\t\tVector3 tempRotation;\n\t\tVector3 tempRestriction;\n\t\t\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//set look:\n\t\ttempRotation=target.transform.eulerAngles;\n\t\tif (args[\"looktarget\"].GetType() == typeof(Transform)) {\n\t\t\t//target.transform.LookAt((Transform)args[\"looktarget\"]);\n\t\t\ttarget.transform.LookAt((Transform)args[\"looktarget\"], (Vector3?)args[\"up\"] ?? Defaults.up);\n\t\t}else if(args[\"looktarget\"].GetType() == typeof(Vector3)){\n\t\t\t//target.transform.LookAt((Vector3)args[\"looktarget\"]);\n\t\t\ttarget.transform.LookAt((Vector3)args[\"looktarget\"], (Vector3?)args[\"up\"] ?? Defaults.up);\n\t\t}\n\t\t\n\t\t//axis restriction:\n\t\tif(args.Contains(\"axis\")){\n\t\t\ttempRestriction=target.transform.eulerAngles;\n\t\t\tswitch((string)args[\"axis\"]){\n\t\t\t\tcase \"x\":\n\t\t\t\t \ttempRestriction.y=tempRotation.y;\n\t\t\t\t\ttempRestriction.z=tempRotation.z;\n\t\t\t\tbreak;\n\t\t\t\tcase \"y\":\n\t\t\t\t\ttempRestriction.x=tempRotation.x;\n\t\t\t\t\ttempRestriction.z=tempRotation.z;\n\t\t\t\tbreak;\n\t\t\t\tcase \"z\":\n\t\t\t\t\ttempRestriction.x=tempRotation.x;\n\t\t\t\t\ttempRestriction.y=tempRotation.y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttarget.transform.eulerAngles=tempRestriction;\n\t\t}\t\t\n\t\t\n\t\t//set new rotation:\n\t\targs[\"rotation\"] = tempRotation;\n\t\t\n\t\t//establish iTween\n\t\targs[\"type\"]=\"rotate\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Rotates a GameObject to look at the supplied Vector3 over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Vector3\"/> to be the Vector3 that the target will look towards.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void LookTo(GameObject target, Vector3 looktarget, float time){\n\t\tLookTo(target,Hash(\"looktarget\",looktarget,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Rotates a GameObject to look at a supplied Transform or Vector3 over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"axis\">\n\t/// A <see cref=\"System.String\"/>. Restricts rotation to the supplied axis only.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void LookTo(GameObject target, Hashtable args){\t\t\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\t\t\t\n\t\t\n\t\t//additional property to ensure ConflictCheck can work correctly since Transforms are refrences:\t\t\n\t\tif(args.Contains(\"looktarget\")){\n\t\t\tif (args[\"looktarget\"].GetType() == typeof(Transform)) {\n\t\t\t\tTransform transform = (Transform)args[\"looktarget\"];\n\t\t\t\targs[\"position\"]=new Vector3(transform.position.x,transform.position.y,transform.position.z);\n\t\t\t\targs[\"rotation\"]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//establish iTween\n\t\targs[\"type\"]=\"look\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Changes a GameObject's position over time to a supplied destination with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"position\">\n\t/// A <see cref=\"Vector3\"/> for the destination Vector3.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void MoveTo(GameObject target, Vector3 position, float time){\n\t\tMoveTo(target,Hash(\"position\",position,\"time\",time));\n\t}\t\n\t\t\n\t/// <summary>\n\t/// Changes a GameObject's position over time to a supplied destination with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"position\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for a point in space the GameObject will animate to.\n\t/// </param>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/> or <see cref=\"Vector3[]\"/> for a list of points to draw a Catmull-Rom through for a curved animation path.\n\t/// </param>\n\t/// <param name=\"movetopath\">\n\t/// A <see cref=\"System.Boolean\"/> for whether to automatically generate a curve from the GameObject's current position to the beginning of the path. True by default.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"orienttopath\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not the GameObject will orient to its direction of travel.  False by default.\n\t/// </param>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Vector3\"/> or A <see cref=\"Transform\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"looktime\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the object will take to look at either the \"looktarget\" or \"orienttopath\".\n\t/// </param>\n\t/// <param name=\"lookahead\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for how much of a percentage to look ahead on a path to influence how strict \"orientopath\" is.\n\t/// </param>\n\t/// <param name=\"axis\">\n\t/// A <see cref=\"System.String\"/>. Restricts rotation to the supplied axis only.\n\t/// </param>\n\t/// <param name=\"islocal\">\n\t/// A <see cref=\"System.Boolean\"/> for whether to animate in world space or relative to the parent. False by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void MoveTo(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//additional property to ensure ConflictCheck can work correctly since Transforms are refrences:\t\t\n\t\tif(args.Contains(\"position\")){\n\t\t\tif (args[\"position\"].GetType() == typeof(Transform)) {\n\t\t\t\tTransform transform = (Transform)args[\"position\"];\n\t\t\t\targs[\"position\"]=new Vector3(transform.position.x,transform.position.y,transform.position.z);\n\t\t\t\targs[\"rotation\"]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);\n\t\t\t\targs[\"scale\"]=new Vector3(transform.localScale.x,transform.localScale.y,transform.localScale.z);\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"move\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\n\t}\n\t\t\n\t/// <summary>\n\t/// Instantly changes a GameObject's position to a supplied destination then returns it to it's starting position over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"position\">\n\t/// A <see cref=\"Vector3\"/> for the destination Vector3.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void MoveFrom(GameObject target, Vector3 position, float time){\n\t\tMoveFrom(target,Hash(\"position\",position,\"time\",time));\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Instantly changes a GameObject's position to a supplied destination then returns it to it's starting position over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"position\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for a point in space the GameObject will animate to.\n\t/// </param>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/> or <see cref=\"Vector3[]\"/> for a list of points to draw a Catmull-Rom through for a curved animation path.\n\t/// </param>\n\t/// <param name=\"movetopath\">\n\t/// A <see cref=\"System.Boolean\"/> for whether to automatically generate a curve from the GameObject's current position to the beginning of the path. True by default.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"orienttopath\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not the GameObject will orient to its direction of travel.  False by default.\n\t/// </param>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Vector3\"/> or A <see cref=\"Transform\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"looktime\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the object will take to look at either the \"looktarget\" or \"orienttopath\".\n\t/// </param>\n\t/// <param name=\"lookahead\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for how much of a percentage to look ahead on a path to influence how strict \"orientopath\" is.\n\t/// </param>\n\t/// <param name=\"islocal\">\n\t/// A <see cref=\"System.Boolean\"/> for whether to animate in world space or relative to the parent. False by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void MoveFrom(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\tbool tempIsLocal;\n\t\t\n\t\t//set tempIsLocal:\n\t\tif(args.Contains(\"islocal\")){\n\t\t\ttempIsLocal = (bool)args[\"islocal\"];\n\t\t}else{\n\t\t\ttempIsLocal = Defaults.isLocal;\t\n\t\t}\n\t\t\n\t\tif(args.Contains(\"path\")){\n\t\t\tVector3[] fromPath;\n\t\t\tVector3[] suppliedPath;\n\t\t\tif(args[\"path\"].GetType() == typeof(Vector3[])){\n\t\t\t\tVector3[] temp = (Vector3[])args[\"path\"];\n\t\t\t\tsuppliedPath=new Vector3[temp.Length];\n\t\t\t\tArray.Copy(temp,suppliedPath, temp.Length);\t\n\t\t\t}else{\n\t\t\t\tTransform[] temp = (Transform[])args[\"path\"];\n\t\t\t\tsuppliedPath = new Vector3[temp.Length];\n\t\t\t\tfor (int i = 0; i < temp.Length; i++) {\n\t\t\t\t\tsuppliedPath[i]=temp[i].position;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(suppliedPath[suppliedPath.Length-1] != target.transform.position){\n\t\t\t\tfromPath= new Vector3[suppliedPath.Length+1];\n\t\t\t\tArray.Copy(suppliedPath,fromPath,suppliedPath.Length);\n\t\t\t\tif(tempIsLocal){\n\t\t\t\t\tfromPath[fromPath.Length-1] = target.transform.localPosition;\n\t\t\t\t\ttarget.transform.localPosition=fromPath[0];\n\t\t\t\t}else{\n\t\t\t\t\tfromPath[fromPath.Length-1] = target.transform.position;\n\t\t\t\t\ttarget.transform.position=fromPath[0];\n\t\t\t\t}\n\t\t\t\targs[\"path\"]=fromPath;\n\t\t\t}else{\n\t\t\t\tif(tempIsLocal){\n\t\t\t\t\ttarget.transform.localPosition=suppliedPath[0];\n\t\t\t\t}else{\n\t\t\t\t\ttarget.transform.position=suppliedPath[0];\n\t\t\t\t}\n\t\t\t\targs[\"path\"]=suppliedPath;\n\t\t\t}\n\t\t}else{\n\t\t\tVector3 tempPosition;\n\t\t\tVector3 fromPosition;\n\t\t\t\n\t\t\t//set tempPosition and base fromPosition:\n\t\t\tif(tempIsLocal){\n\t\t\t\ttempPosition=fromPosition=target.transform.localPosition;\n\t\t\t}else{\n\t\t\t\ttempPosition=fromPosition=target.transform.position;\t\n\t\t\t}\n\t\t\t\n\t\t\t//set augmented fromPosition:\n\t\t\tif(args.Contains(\"position\")){\n\t\t\t\tif (args[\"position\"].GetType() == typeof(Transform)){\n\t\t\t\t\tTransform trans = (Transform)args[\"position\"];\n\t\t\t\t\tfromPosition=trans.position;\n\t\t\t\t}else if(args[\"position\"].GetType() == typeof(Vector3)){\n\t\t\t\t\tfromPosition=(Vector3)args[\"position\"];\n\t\t\t\t}\t\t\t\n\t\t\t}else{\n\t\t\t\tif (args.Contains(\"x\")) {\n\t\t\t\t\tfromPosition.x=(float)args[\"x\"];\n\t\t\t\t}\n\t\t\t\tif (args.Contains(\"y\")) {\n\t\t\t\t\tfromPosition.y=(float)args[\"y\"];\n\t\t\t\t}\n\t\t\t\tif (args.Contains(\"z\")) {\n\t\t\t\t\tfromPosition.z=(float)args[\"z\"];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//apply fromPosition:\n\t\t\tif(tempIsLocal){\n\t\t\t\ttarget.transform.localPosition = fromPosition;\n\t\t\t}else{\n\t\t\t\ttarget.transform.position = fromPosition;\t\n\t\t\t}\n\t\t\t\n\t\t\t//set new position arg:\n\t\t\targs[\"position\"]=tempPosition;\n\t\t}\n\t\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"move\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\n\t}\n\t\t\n\t/// <summary>\n\t/// Translates a GameObject's position over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount of change in position to move the GameObject.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void MoveAdd(GameObject target, Vector3 amount, float time){\n\t\tMoveAdd(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Translates a GameObject's position over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount of change in position to move the GameObject.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"orienttopath\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not the GameObject will orient to its direction of travel.  False by default.\n\t/// </param>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Vector3\"/> or A <see cref=\"Transform\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"looktime\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the object will take to look at either the \"looktarget\" or \"orienttopath\".\n\t/// </param>\n\t/// <param name=\"axis\">\n\t/// A <see cref=\"System.String\"/>. Restricts rotation to the supplied axis only.\n\t/// </param>\n\t/// <param name=\"space\">\n\t/// A <see cref=\"Space\"/> or <see cref=\"System.String\"/> for applying the transformation in either the world coordinate or local cordinate system. Defaults to local space.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void MoveAdd(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"move\";\n\t\targs[\"method\"]=\"add\";\n\t\tLaunch(target,args);\n\t}\n\t\n\t/// <summary>\n\t/// Adds the supplied coordinates to a GameObject's postion with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount of change in position to move the GameObject.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void MoveBy(GameObject target, Vector3 amount, float time){\n\t\tMoveBy(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Adds the supplied coordinates to a GameObject's position with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount of change in position to move the GameObject.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"orienttopath\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not the GameObject will orient to its direction of travel.  False by default.\n\t/// </param>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Vector3\"/> or A <see cref=\"Transform\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"looktime\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the object will take to look at either the \"looktarget\" or \"orienttopath\".\n\t/// </param>\n\t/// <param name=\"axis\">\n\t/// A <see cref=\"System.String\"/>. Restricts rotation to the supplied axis only.\n\t/// </param>\n\t/// <param name=\"space\">\n\t/// A <see cref=\"Space\"/> or <see cref=\"System.String\"/> for applying the transformation in either the world coordinate or local cordinate system. Defaults to local space.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void MoveBy(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"move\";\n\t\targs[\"method\"]=\"by\";\n\t\tLaunch(target,args);\n\t}\n\t\n\t/// <summary>\n\t/// Changes a GameObject's scale over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"scale\">\n\t/// A <see cref=\"Vector3\"/> for the final scale.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ScaleTo(GameObject target, Vector3 scale, float time){\n\t\tScaleTo(target,Hash(\"scale\",scale,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Changes a GameObject's scale over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"scale\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for the final scale.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void ScaleTo(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//additional property to ensure ConflictCheck can work correctly since Transforms are refrences:\t\t\n\t\tif(args.Contains(\"scale\")){\n\t\t\tif (args[\"scale\"].GetType() == typeof(Transform)) {\n\t\t\t\tTransform transform = (Transform)args[\"scale\"];\n\t\t\t\targs[\"position\"]=new Vector3(transform.position.x,transform.position.y,transform.position.z);\n\t\t\t\targs[\"rotation\"]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);\n\t\t\t\targs[\"scale\"]=new Vector3(transform.localScale.x,transform.localScale.y,transform.localScale.z);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"scale\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\n\t}\n\t\n\t/// <summary>\n\t/// Instantly changes a GameObject's scale then returns it to it's starting scale over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"scale\">\n\t/// A <see cref=\"Vector3\"/> for the final scale.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ScaleFrom(GameObject target, Vector3 scale, float time){\n\t\tScaleFrom(target,Hash(\"scale\",scale,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Instantly changes a GameObject's scale then returns it to it's starting scale over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"scale\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for the final scale.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void ScaleFrom(GameObject target, Hashtable args){\n\t\tVector3 tempScale;\n\t\tVector3 fromScale;\n\t\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//set base fromScale:\n\t\ttempScale=fromScale=target.transform.localScale;\n\t\t\n\t\t//set augmented fromScale:\n\t\tif(args.Contains(\"scale\")){\n\t\t\tif (args[\"scale\"].GetType() == typeof(Transform)){\n\t\t\t\tTransform trans = (Transform)args[\"scale\"];\n\t\t\t\tfromScale=trans.localScale;\n\t\t\t}else if(args[\"scale\"].GetType() == typeof(Vector3)){\n\t\t\t\tfromScale=(Vector3)args[\"scale\"];\n\t\t\t}\t\n\t\t}else{\n\t\t\tif (args.Contains(\"x\")) {\n\t\t\t\tfromScale.x=(float)args[\"x\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"y\")) {\n\t\t\t\tfromScale.y=(float)args[\"y\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"z\")) {\n\t\t\t\tfromScale.z=(float)args[\"z\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//apply fromScale:\n\t\ttarget.transform.localScale = fromScale;\t\n\t\t\n\t\t//set new scale arg:\n\t\targs[\"scale\"]=tempScale;\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"scale\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\n\t}\n\t\n\t/// <summary>\n\t/// Adds to a GameObject's scale over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount of scale to be added to the GameObject's current scale.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ScaleAdd(GameObject target, Vector3 amount, float time){\n\t\tScaleAdd(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Adds to a GameObject's scale over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount to be added to the GameObject's current scale.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void ScaleAdd(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"scale\";\n\t\targs[\"method\"]=\"add\";\n\t\tLaunch(target,args);\n\t}\n\t\n\t/// <summary>\n\t/// Multiplies a GameObject's scale over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount of scale to be multiplied by the GameObject's current scale.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ScaleBy(GameObject target, Vector3 amount, float time){\n\t\tScaleBy(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Multiplies a GameObject's scale over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount to be multiplied to the GameObject's current scale.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void ScaleBy(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"scale\";\n\t\targs[\"method\"]=\"by\";\n\t\tLaunch(target,args);\n\t}\n\t\n\t/// <summary>\n\t/// Rotates a GameObject to the supplied Euler angles in degrees over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"rotation\">\n\t/// A <see cref=\"Vector3\"/> for the target Euler angles in degrees to rotate to.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void RotateTo(GameObject target, Vector3 rotation, float time){\n\t\tRotateTo(target,Hash(\"rotation\",rotation,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Rotates a GameObject to the supplied Euler angles in degrees over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"rotation\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for the target Euler angles in degrees to rotate to.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"islocal\">\n\t/// A <see cref=\"System.Boolean\"/> for whether to animate in world space or relative to the parent. False by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void RotateTo(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//additional property to ensure ConflictCheck can work correctly since Transforms are refrences:\t\t\n\t\tif(args.Contains(\"rotation\")){\n\t\t\tif (args[\"rotation\"].GetType() == typeof(Transform)) {\n\t\t\t\tTransform transform = (Transform)args[\"rotation\"];\n\t\t\t\targs[\"position\"]=new Vector3(transform.position.x,transform.position.y,transform.position.z);\n\t\t\t\targs[\"rotation\"]=new Vector3(transform.eulerAngles.x,transform.eulerAngles.y,transform.eulerAngles.z);\n\t\t\t\targs[\"scale\"]=new Vector3(transform.localScale.x,transform.localScale.y,transform.localScale.z);\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\t//establish iTween\n\t\targs[\"type\"]=\"rotate\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\n\t}\t\n\t\n\t/// <summary>\n\t/// Instantly changes a GameObject's Euler angles in degrees then returns it to it's starting rotation over time (if allowed) with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"rotation\">\n\t/// A <see cref=\"Vector3\"/> for the target Euler angles in degrees to rotate from.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void RotateFrom(GameObject target, Vector3 rotation, float time){\n\t\tRotateFrom(target,Hash(\"rotation\",rotation,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Instantly changes a GameObject's Euler angles in degrees then returns it to it's starting rotation over time (if allowed) with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"rotation\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for the target Euler angles in degrees to rotate to.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"islocal\">\n\t/// A <see cref=\"System.Boolean\"/> for whether to animate in world space or relative to the parent. False by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void RotateFrom(GameObject target, Hashtable args){\n\t\tVector3 tempRotation;\n\t\tVector3 fromRotation;\n\t\tbool tempIsLocal;\n\t\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//set tempIsLocal:\n\t\tif(args.Contains(\"islocal\")){\n\t\t\ttempIsLocal = (bool)args[\"islocal\"];\n\t\t}else{\n\t\t\ttempIsLocal = Defaults.isLocal;\t\n\t\t}\n\n\t\t//set tempRotation and base fromRotation:\n\t\tif(tempIsLocal){\n\t\t\ttempRotation=fromRotation=target.transform.localEulerAngles;\n\t\t}else{\n\t\t\ttempRotation=fromRotation=target.transform.eulerAngles;\t\n\t\t}\n\t\t\n\t\t//set augmented fromRotation:\n\t\tif(args.Contains(\"rotation\")){\n\t\t\tif (args[\"rotation\"].GetType() == typeof(Transform)){\n\t\t\t\tTransform trans = (Transform)args[\"rotation\"];\n\t\t\t\tfromRotation=trans.eulerAngles;\n\t\t\t}else if(args[\"rotation\"].GetType() == typeof(Vector3)){\n\t\t\t\tfromRotation=(Vector3)args[\"rotation\"];\n\t\t\t}\t\n\t\t}else{\n\t\t\tif (args.Contains(\"x\")) {\n\t\t\t\tfromRotation.x=(float)args[\"x\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"y\")) {\n\t\t\t\tfromRotation.y=(float)args[\"y\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"z\")) {\n\t\t\t\tfromRotation.z=(float)args[\"z\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//apply fromRotation:\n\t\tif(tempIsLocal){\n\t\t\ttarget.transform.localEulerAngles = fromRotation;\n\t\t}else{\n\t\t\ttarget.transform.eulerAngles = fromRotation;\t\n\t\t}\n\t\t\n\t\t//set new rotation arg:\n\t\targs[\"rotation\"]=tempRotation;\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"rotate\";\n\t\targs[\"method\"]=\"to\";\n\t\tLaunch(target,args);\n\t}\t\n\t\n\t/// <summary>\n\t/// Adds supplied Euler angles in degrees to a GameObject's rotation over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount of Euler angles in degrees to add to the current rotation of the GameObject.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void RotateAdd(GameObject target, Vector3 amount, float time){\n\t\tRotateAdd(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Adds supplied Euler angles in degrees to a GameObject's rotation over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount of Euler angles in degrees to add to the current rotation of the GameObject.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"space\">\n\t/// A <see cref=\"Space\"/> or <see cref=\"System.String\"/> for applying the transformation in either the world coordinate or local cordinate system. Defaults to local space.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void RotateAdd(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween:\n\t\targs[\"type\"]=\"rotate\";\n\t\targs[\"method\"]=\"add\";\n\t\tLaunch(target,args);\n\t}\n\t\n\t/// <summary>\n\t/// Multiplies supplied values by 360 and rotates a GameObject by calculated amount over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount to be multiplied by 360 to rotate the GameObject.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void RotateBy(GameObject target, Vector3 amount, float time){\n\t\tRotateBy(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Multiplies supplied values by 360 and rotates a GameObject by calculated amount over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the amount to be multiplied by 360 to rotate the GameObject.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"space\">\n\t/// A <see cref=\"Space\"/> or <see cref=\"System.String\"/> for applying the transformation in either the world coordinate or local cordinate system. Defaults to local space.\n\t/// </param>\n\t/// <param name=\"islocal\">\n\t/// A <see cref=\"System.Boolean\"/> for whether to animate in world space or relative to the parent. False by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"speed\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> can be used instead of time to allow animation based on speed\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"easetype\">\n\t/// A <see cref=\"EaseType\"/> or <see cref=\"System.String\"/> for the shape of the easing curve applied to the animation.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed.\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void RotateBy(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween\n\t\targs[\"type\"]=\"rotate\";\n\t\targs[\"method\"]=\"by\";\n\t\tLaunch(target,args);\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Randomly shakes a GameObject's position by a diminishing amount over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of shake.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ShakePosition(GameObject target, Vector3 amount, float time){\n\t\tShakePosition(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Randomly shakes a GameObject's position by a diminishing amount over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of shake.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x magnitude.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y magnitude.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z magnitude.\n\t/// </param>\n\t/// <param name=\"islocal\">\n\t/// A <see cref=\"System.Boolean\"/> for whether to animate in world space or relative to the parent. False by default.\n\t/// </param>\n\t/// <param name=\"orienttopath\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not the GameObject will orient to its direction of travel.  False by default.\n\t/// </param>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Vector3\"/> or A <see cref=\"Transform\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"looktime\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the object will take to look at either the \"looktarget\" or \"orienttopath\".\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>  \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed. (only \"loop\" is allowed with shakes)\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void ShakePosition(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween\n\t\targs[\"type\"]=\"shake\";\n\t\targs[\"method\"]=\"position\";\n\t\tLaunch(target,args);\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Randomly shakes a GameObject's scale by a diminishing amount over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of shake.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ShakeScale(GameObject target, Vector3 amount, float time){\n\t\tShakeScale(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Randomly shakes a GameObject's scale by a diminishing amount over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of shake.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x magnitude.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y magnitude.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z magnitude.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed. (only \"loop\" is allowed with shakes)\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void ShakeScale(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween\n\t\targs[\"type\"]=\"shake\";\n\t\targs[\"method\"]=\"scale\";\n\t\tLaunch(target,args);\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Randomly shakes a GameObject's rotation by a diminishing amount over time with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of shake.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ShakeRotation(GameObject target, Vector3 amount, float time){\n\t\tShakeRotation(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Randomly shakes a GameObject's rotation by a diminishing amount over time with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of shake.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x magnitude.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y magnitude.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z magnitude.\n\t/// </param>\n\t/// <param name=\"space\">\n\t/// A <see cref=\"Space\"/> for applying the transformation in either the world coordinate or local cordinate system. Defaults to local space.\n\t/// </param> \n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>\n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed. (only \"loop\" is allowed with shakes)\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void ShakeRotation(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween\n\t\targs[\"type\"]=\"shake\";\n\t\targs[\"method\"]=\"rotation\";\n\t\tLaunch(target,args);\n\t}\t\t\t\n\t\n\t/// <summary>\n\t/// Applies a jolt of force to a GameObject's position and wobbles it back to its initial position with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of the punch.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void PunchPosition(GameObject target, Vector3 amount, float time){\n\t\tPunchPosition(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Applies a jolt of force to a GameObject's position and wobbles it back to its initial position with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of shake.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x magnitude.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y magnitude.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z magnitude.\n\t/// </param>\n\t/// <param name=\"space\">\n\t/// A <see cref=\"Space\"/> for applying the transformation in either the world coordinate or local cordinate system. Defaults to local space.\n\t/// </param> \n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Vector3\"/> or A <see cref=\"Transform\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"looktime\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the object will take to look at either the \"looktarget\".\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param>   \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed. (only \"loop\" is allowed with punches)\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void PunchPosition(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween\n\t\targs[\"type\"]=\"punch\";\n\t\targs[\"method\"]=\"position\";\n\t\targs[\"easetype\"]=EaseType.punch;\n\t\tLaunch(target,args);\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Applies a jolt of force to a GameObject's rotation and wobbles it back to its initial rotation with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of the punch.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void PunchRotation(GameObject target, Vector3 amount, float time){\n\t\tPunchRotation(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Applies a jolt of force to a GameObject's rotation and wobbles it back to its initial rotation with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of shake.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x magnitude.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y magnitude.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z magnitude.\n\t/// </param>\n\t/// <param name=\"space\">\n\t/// A <see cref=\"Space\"/> for applying the transformation in either the world coordinate or local cordinate system. Defaults to local space.\n\t/// </param> \n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param> \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed. (only \"loop\" is allowed with punches)\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void PunchRotation(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween\n\t\targs[\"type\"]=\"punch\";\n\t\targs[\"method\"]=\"rotation\";\n\t\targs[\"easetype\"]=EaseType.punch;\n\t\tLaunch(target,args);\n\t}\t\n\t\n\t/// <summary>\n\t/// Applies a jolt of force to a GameObject's scale and wobbles it back to its initial scale with MINIMUM customization options.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of the punch.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void PunchScale(GameObject target, Vector3 amount, float time){\n\t\tPunchScale(target,Hash(\"amount\",amount,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Applies a jolt of force to a GameObject's scale and wobbles it back to its initial scale with FULL customization options.\n\t/// </summary>\n\t/// <param name=\"amount\">\n\t/// A <see cref=\"Vector3\"/> for the magnitude of shake.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x magnitude.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y magnitude.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z magnitude.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\t/// <param name=\"delay\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will wait before beginning.\n\t/// </param> \n\t/// <param name=\"looptype\">\n\t/// A <see cref=\"LoopType\"/> or <see cref=\"System.String\"/> for the type of loop to apply once the animation has completed. (only \"loop\" is allowed with punches)\n\t/// </param>\n\t/// <param name=\"onstart\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the beginning of the animation.\n\t/// </param>\n\t/// <param name=\"onstarttarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onstartparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onstart\" method.\n\t/// </param>\n\t/// <param name=\"onupdate\"> \n\t/// A <see cref=\"System.String\"/> for the name of a function to launch on every step of the animation.\n\t/// </param>\n\t/// <param name=\"onupdatetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"onupdate\" method.\n\t/// </param>\n\t/// <param name=\"onupdateparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"onupdate\" method.\n\t/// </param> \n\t/// <param name=\"oncomplete\">\n\t/// A <see cref=\"System.String\"/> for the name of a function to launch at the end of the animation.\n\t/// </param>\n\t/// <param name=\"oncompletetarget\">\n\t/// A <see cref=\"GameObject\"/> for a reference to the GameObject that holds the \"oncomplete\" method.\n\t/// </param>\n\t/// <param name=\"oncompleteparams\">\n\t/// A <see cref=\"System.Object\"/> for arguments to be sent to the \"oncomplete\" method.\n\t/// </param>\n\tpublic static void PunchScale(GameObject target, Hashtable args){\n\t\t//clean args:\n\t\targs = iTween.CleanArgs(args);\n\t\t\n\t\t//establish iTween\n\t\targs[\"type\"]=\"punch\";\n\t\targs[\"method\"]=\"scale\";\n\t\targs[\"easetype\"]=EaseType.punch;\n\t\tLaunch(target,args);\n\t}\t\n\t\n\t#endregion\n\t\n\t#region #2 Generate Method Targets\n\t\n\t//call correct set target method and set tween application delegate:\n\tvoid GenerateTargets(){\n\t\tswitch (type) {\n\t\t\tcase \"value\":\n\t\t\t\tswitch (method) {\n\t\t\t\t\tcase \"float\":\n\t\t\t\t\t\tGenerateFloatTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyFloatTargets);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"vector2\":\n\t\t\t\t\t\tGenerateVector2Targets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyVector2Targets);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"vector3\":\n\t\t\t\t\t\tGenerateVector3Targets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyVector3Targets);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"color\":\n\t\t\t\t\t\tGenerateColorTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyColorTargets);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"rect\":\n\t\t\t\t\t\tGenerateRectTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyRectTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"color\":\n\t\t\t\tswitch (method) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tGenerateColorToTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyColorToTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"audio\":\n\t\t\t\tswitch (method) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tGenerateAudioToTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyAudioToTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"move\":\n\t\t\t\tswitch (method) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\t//using a path?\n\t\t\t\t\t\tif(tweenArguments.Contains(\"path\")){\n\t\t\t\t\t\t\tGenerateMoveToPathTargets();\n\t\t\t\t\t\t\tapply = new ApplyTween(ApplyMoveToPathTargets);\n\t\t\t\t\t\t}else{ //not using a path?\n\t\t\t\t\t\t\tGenerateMoveToTargets();\n\t\t\t\t\t\t\tapply = new ApplyTween(ApplyMoveToTargets);\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"by\":\n\t\t\t\t\tcase \"add\":\n\t\t\t\t\t\tGenerateMoveByTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyMoveByTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"scale\":\n\t\t\t\tswitch (method){\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tGenerateScaleToTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyScaleToTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"by\":\n\t\t\t\t\t\tGenerateScaleByTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyScaleToTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"add\":\n\t\t\t\t\t\tGenerateScaleAddTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyScaleToTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"rotate\":\n\t\t\t\tswitch (method) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tGenerateRotateToTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyRotateToTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"add\":\n\t\t\t\t\t\tGenerateRotateAddTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyRotateAddTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"by\":\n\t\t\t\t\t\tGenerateRotateByTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyRotateAddTargets);\n\t\t\t\t\tbreak;\t\t\t\t\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"shake\":\n\t\t\t\tswitch (method) {\n\t\t\t\t\tcase \"position\":\n\t\t\t\t\t\tGenerateShakePositionTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyShakePositionTargets);\n\t\t\t\t\tbreak;\t\t\n\t\t\t\t\tcase \"scale\":\n\t\t\t\t\t\tGenerateShakeScaleTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyShakeScaleTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"rotation\":\n\t\t\t\t\t\tGenerateShakeRotationTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyShakeRotationTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\t\t\t\n\t\t\tcase \"punch\":\n\t\t\t\tswitch (method) {\n\t\t\t\t\tcase \"position\":\n\t\t\t\t\t\tGeneratePunchPositionTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyPunchPositionTargets);\n\t\t\t\t\tbreak;\t\n\t\t\t\t\tcase \"rotation\":\n\t\t\t\t\t\tGeneratePunchRotationTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyPunchRotationTargets);\n\t\t\t\t\tbreak;\t\n\t\t\t\t\tcase \"scale\":\n\t\t\t\t\t\tGeneratePunchScaleTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyPunchScaleTargets);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"look\":\n\t\t\t\tswitch (method) {\n\t\t\t\t\tcase \"to\":\n\t\t\t\t\t\tGenerateLookToTargets();\n\t\t\t\t\t\tapply = new ApplyTween(ApplyLookToTargets);\n\t\t\t\t\tbreak;\t\n\t\t\t\t}\n\t\t\tbreak;\t\n\t\t\tcase \"stab\":\n\t\t\t\tGenerateStabTargets();\n\t\t\t\tapply = new ApplyTween(ApplyStabTargets);\n\t\t\tbreak;\t\n\t\t}\n\t}\n\t\n\t#endregion\n\t\n\t#region #3 Generate Specific Targets\n\t\n\tvoid GenerateRectTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\trects=new Rect[3];\n\t\t\n\t\t//from and to values:\n\t\trects[0]=(Rect)tweenArguments[\"from\"];\n\t\trects[1]=(Rect)tweenArguments[\"to\"];\n\t}\t\t\n\t\n\tvoid GenerateColorTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tcolors=new Color[1,3];\n\t\t\n\t\t//from and to values:\n\t\tcolors[0,0]=(Color)tweenArguments[\"from\"];\n\t\tcolors[0,1]=(Color)tweenArguments[\"to\"];\n\t}\t\n\t\n\tvoid GenerateVector3Targets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tvector3s=new Vector3[3];\n\t\t\n\t\t//from and to values:\n\t\tvector3s[0]=(Vector3)tweenArguments[\"from\"];\n\t\tvector3s[1]=(Vector3)tweenArguments[\"to\"];\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\n\t\n\tvoid GenerateVector2Targets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tvector2s=new Vector2[3];\n\t\t\n\t\t//from and to values:\n\t\tvector2s[0]=(Vector2)tweenArguments[\"from\"];\n\t\tvector2s[1]=(Vector2)tweenArguments[\"to\"];\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tVector3 fromV3 = new Vector3(vector2s[0].x,vector2s[0].y,0);\n\t\t\tVector3 toV3 = new Vector3(vector2s[1].x,vector2s[1].y,0);\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(fromV3,toV3));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\n\t\n\tvoid GenerateFloatTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tfloats=new float[3];\n\t\t\n\t\t//from and to values:\n\t\tfloats[0]=(float)tweenArguments[\"from\"];\n\t\tfloats[1]=(float)tweenArguments[\"to\"];\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(floats[0] - floats[1]);\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\n\t\t\n\tvoid GenerateColorToTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\t//colors = new Color[3];\n\t\t\n\t\t//from and init to values:\n\t\tif(GetComponent(typeof(GUITexture))){\n\t\t\tcolors = new Color[1,3];\n\t\t\tcolors[0,0] = colors[0,1] = guiTexture.color;\n\t\t}else if(GetComponent(typeof(GUIText))){\n\t\t\tcolors = new Color[1,3];\n\t\t\tcolors[0,0] = colors[0,1] = guiText.material.color;\n\t\t}else if(renderer){\n\t\t\tcolors = new Color[renderer.materials.Length,3];\n\t\t\tfor (int i = 0; i < renderer.materials.Length; i++) {\n\t\t\t\tcolors[i,0]=renderer.materials[i].GetColor(namedcolorvalue.ToString());\n\t\t\t\tcolors[i,1]=renderer.materials[i].GetColor(namedcolorvalue.ToString());\n\t\t\t}\n\t\t\t//colors[0] = colors[1] = renderer.material.color;\t\n\t\t}else if(light){\n\t\t\tcolors = new Color[1,3];\n\t\t\tcolors[0,0] = colors[0,1] = light.color;\t\n\t\t}else{\n\t\t\tcolors = new Color[1,3]; //empty placeholder incase the GO is perhaps an empty holder or something similar\n\t\t}\n\t\t\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"color\")) {\n\t\t\t//colors[1]=(Color)tweenArguments[\"color\"];\n\t\t\tfor (int i = 0; i < colors.GetLength(0); i++) {\n\t\t\t\tcolors[i,1]=(Color)tweenArguments[\"color\"];\n\t\t\t}\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"r\")) {\n\t\t\t\t//colors[1].r=(float)tweenArguments[\"r\"];\n\t\t\t\tfor (int i = 0; i < colors.GetLength(0); i++) {\n\t\t\t\t\tcolors[i,1].r=(float)tweenArguments[\"r\"];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"g\")) {\n\t\t\t\t//colors[1].g=(float)tweenArguments[\"g\"];\n\t\t\t\tfor (int i = 0; i < colors.GetLength(0); i++) {\n\t\t\t\t\tcolors[i,1].g=(float)tweenArguments[\"g\"];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"b\")) {\n\t\t\t\t//colors[1].b=(float)tweenArguments[\"b\"];\n\t\t\t\tfor (int i = 0; i < colors.GetLength(0); i++) {\n\t\t\t\t\tcolors[i,1].b=(float)tweenArguments[\"b\"];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"a\")) {\n\t\t\t\t//colors[1].a=(float)tweenArguments[\"a\"];\n\t\t\t\tfor (int i = 0; i < colors.GetLength(0); i++) {\n\t\t\t\t\tcolors[i,1].a=(float)tweenArguments[\"a\"];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//alpha or amount?\n\t\tif(tweenArguments.Contains(\"amount\")){\n\t\t\t//colors[1].a=(float)tweenArguments[\"amount\"];\n\t\t\tfor (int i = 0; i < colors.GetLength(0); i++) {\n\t\t\t\tcolors[i,1].a=(float)tweenArguments[\"amount\"];\n\t\t\t}\n\t\t}else if(tweenArguments.Contains(\"alpha\")){\n\t\t\t//colors[1].a=(float)tweenArguments[\"alpha\"];\n\t\t\tfor (int i = 0; i < colors.GetLength(0); i++) {\n\t\t\t\tcolors[i,1].a=(float)tweenArguments[\"alpha\"];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid GenerateAudioToTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tvector2s=new Vector2[3];\n\t\t\n\t\t//set audioSource:\n\t\tif(tweenArguments.Contains(\"audiosource\")){\n\t\t\taudioSource=(AudioSource)tweenArguments[\"audiosource\"];\n\t\t}else{\n\t\t\tif(GetComponent(typeof(AudioSource))){\n\t\t\t\taudioSource=audio;\n\t\t\t}else{\n\t\t\t\t//throw error if no AudioSource is available:\n\t\t\t\tDebug.LogError(\"iTween Error: AudioTo requires an AudioSource.\");\n\t\t\t\tDispose();\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\t//from values and default to values:\n\t\tvector2s[0]=vector2s[1]=new Vector2(audioSource.volume,audioSource.pitch);\n\t\t\t\t\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"volume\")) {\n\t\t\tvector2s[1].x=(float)tweenArguments[\"volume\"];\t\n\t\t}\n\t\tif (tweenArguments.Contains(\"pitch\")) {\n\t\t\tvector2s[1].y=(float)tweenArguments[\"pitch\"];\t\n\t\t}\n\t}\n\t\n\tvoid GenerateStabTargets(){\n\t\t//set audioSource:\n\t\tif(tweenArguments.Contains(\"audiosource\")){\n\t\t\taudioSource=(AudioSource)tweenArguments[\"audiosource\"];\n\t\t}else{\n\t\t\tif(GetComponent(typeof(AudioSource))){\n\t\t\t\taudioSource=audio;\n\t\t\t}else{\n\t\t\t\t//add and populate AudioSource if one doesn't exist:\n\t\t\t\tgameObject.AddComponent(typeof(AudioSource));\n\t\t\t\taudioSource=audio;\n\t\t\t\taudioSource.playOnAwake=false;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t//populate audioSource's clip:\n\t\taudioSource.clip=(AudioClip)tweenArguments[\"audioclip\"];\n\t\t\n\t\t//set audio's pitch and volume if requested:\n\t\tif(tweenArguments.Contains(\"pitch\")){\n\t\t\taudioSource.pitch=(float)tweenArguments[\"pitch\"];\n\t\t}\n\t\tif(tweenArguments.Contains(\"volume\")){\n\t\t\taudioSource.volume=(float)tweenArguments[\"volume\"];\n\t\t}\n\t\t\t\n\t\t//set run time based on length of clip after pitch is augmented\n\t\ttime=audioSource.clip.length/audioSource.pitch;\n\t}\n\t\n\tvoid GenerateLookToTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tvector3s=new Vector3[3];\n\t\t\n\t\t//from values:\n\t\tvector3s[0]=transform.eulerAngles;\n\t\t\n\t\t//set look:\n\t\tif(tweenArguments.Contains(\"looktarget\")){\n\t\t\tif (tweenArguments[\"looktarget\"].GetType() == typeof(Transform)) {\n\t\t\t\t//transform.LookAt((Transform)tweenArguments[\"looktarget\"]);\n\t\t\t\ttransform.LookAt((Transform)tweenArguments[\"looktarget\"], (Vector3?)tweenArguments[\"up\"] ?? Defaults.up);\n\t\t\t}else if(tweenArguments[\"looktarget\"].GetType() == typeof(Vector3)){\n\t\t\t\t//transform.LookAt((Vector3)tweenArguments[\"looktarget\"]);\n\t\t\t\ttransform.LookAt((Vector3)tweenArguments[\"looktarget\"], (Vector3?)tweenArguments[\"up\"] ?? Defaults.up);\n\t\t\t}\n\t\t}else{\n\t\t\tDebug.LogError(\"iTween Error: LookTo needs a 'looktarget' property!\");\n\t\t\tDispose();\n\t\t}\n\n\t\t//to values:\n\t\tvector3s[1]=transform.eulerAngles;\n\t\ttransform.eulerAngles=vector3s[0];\n\t\t\n\t\t//axis restriction:\n\t\tif(tweenArguments.Contains(\"axis\")){\n\t\t\tswitch((string)tweenArguments[\"axis\"]){\n\t\t\t\tcase \"x\":\n\t\t\t\t\tvector3s[1].y=vector3s[0].y;\n\t\t\t\t\tvector3s[1].z=vector3s[0].z;\n\t\t\t\tbreak;\n\t\t\t\tcase \"y\":\n\t\t\t\t\tvector3s[1].x=vector3s[0].x;\n\t\t\t\t\tvector3s[1].z=vector3s[0].z;\n\t\t\t\tbreak;\n\t\t\t\tcase \"z\":\n\t\t\t\t\tvector3s[1].x=vector3s[0].x;\n\t\t\t\t\tvector3s[1].y=vector3s[0].y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//shortest distance:\n\t\tvector3s[1]=new Vector3(clerp(vector3s[0].x,vector3s[1].x,1),clerp(vector3s[0].y,vector3s[1].y,1),clerp(vector3s[0].z,vector3s[1].z,1));\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\t\n\t\n\tvoid GenerateMoveToPathTargets(){\n\t\t Vector3[] suppliedPath;\n\t\t\n\t\t//create and store path points:\n\t\tif(tweenArguments[\"path\"].GetType() == typeof(Vector3[])){\n\t\t\tVector3[] temp = (Vector3[])tweenArguments[\"path\"];\n\t\t\t//if only one point is supplied fall back to MoveTo's traditional use since we can't have a curve with one value:\n\t\t\tif(temp.Length==1){\n\t\t\t\tDebug.LogError(\"iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!\");\n\t\t\t\tDispose();\n\t\t\t}\n\t\t\tsuppliedPath=new Vector3[temp.Length];\n\t\t\tArray.Copy(temp,suppliedPath, temp.Length);\n\t\t}else{\n\t\t\tTransform[] temp = (Transform[])tweenArguments[\"path\"];\n\t\t\t//if only one point is supplied fall back to MoveTo's traditional use since we can't have a curve with one value:\n\t\t\tif(temp.Length==1){\n\t\t\t\tDebug.LogError(\"iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!\");\n\t\t\t\tDispose();\n\t\t\t}\n\t\t\tsuppliedPath = new Vector3[temp.Length];\n\t\t\tfor (int i = 0; i < temp.Length; i++) {\n\t\t\t\tsuppliedPath[i]=temp[i].position;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//do we need to plot a path to get to the beginning of the supplied path?\t\t\n\t\tbool plotStart;\n\t\tint offset;\n\t\tif(transform.position != suppliedPath[0]){\n\t\t\tif(!tweenArguments.Contains(\"movetopath\") || (bool)tweenArguments[\"movetopath\"]==true){\n\t\t\t\tplotStart=true;\n\t\t\t\toffset=3;\t\n\t\t\t}else{\n\t\t\t\tplotStart=false;\n\t\t\t\toffset=2;\n\t\t\t}\n\t\t}else{\n\t\t\tplotStart=false;\n\t\t\toffset=2;\n\t\t}\t\t\t\t\n\n\t\t//build calculated path:\n\t\tvector3s = new Vector3[suppliedPath.Length+offset];\n\t\tif(plotStart){\n\t\t\tvector3s[1]=transform.position;\n\t\t\toffset=2;\n\t\t}else{\n\t\t\toffset=1;\n\t\t}\t\t\n\t\t\n\t\t//populate calculate path;\n\t\tArray.Copy(suppliedPath,0,vector3s,offset,suppliedPath.Length);\n\t\t\n\t\t//populate start and end control points:\n\t\t//vector3s[0] = vector3s[1] - vector3s[2];\n\t\tvector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);\n\t\tvector3s[vector3s.Length-1] = vector3s[vector3s.Length-2] + (vector3s[vector3s.Length-2] - vector3s[vector3s.Length-3]);\n\t\t\n\t\t//is this a closed, continuous loop? yes? well then so let's make a continuous Catmull-Rom spline!\n\t\tif(vector3s[1] == vector3s[vector3s.Length-2]){\n\t\t\tVector3[] tmpLoopSpline = new Vector3[vector3s.Length];\n\t\t\tArray.Copy(vector3s,tmpLoopSpline,vector3s.Length);\n\t\t\ttmpLoopSpline[0]=tmpLoopSpline[tmpLoopSpline.Length-3];\n\t\t\ttmpLoopSpline[tmpLoopSpline.Length-1]=tmpLoopSpline[2];\n\t\t\tvector3s=new Vector3[tmpLoopSpline.Length];\n\t\t\tArray.Copy(tmpLoopSpline,vector3s,tmpLoopSpline.Length);\n\t\t}\n\t\t\n\t\t//create Catmull-Rom path:\n\t\tpath = new CRSpline(vector3s);\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = PathLength(vector3s);\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\n\t\n\tvoid GenerateMoveToTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tvector3s=new Vector3[3];\n\t\t\n\t\t//from values:\n\t\tif (isLocal) {\n\t\t\tvector3s[0]=vector3s[1]=transform.localPosition;\t\t\t\t\n\t\t}else{\n\t\t\tvector3s[0]=vector3s[1]=transform.position;\n\t\t}\n\t\t\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"position\")) {\n\t\t\tif (tweenArguments[\"position\"].GetType() == typeof(Transform)){\n\t\t\t\tTransform trans = (Transform)tweenArguments[\"position\"];\n\t\t\t\tvector3s[1]=trans.position;\n\t\t\t}else if(tweenArguments[\"position\"].GetType() == typeof(Vector3)){\n\t\t\t\tvector3s[1]=(Vector3)tweenArguments[\"position\"];\n\t\t\t}\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//handle orient to path request:\n\t\tif(tweenArguments.Contains(\"orienttopath\") && (bool)tweenArguments[\"orienttopath\"]){\n\t\t\ttweenArguments[\"looktarget\"] = vector3s[1];\n\t\t}\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\n\t\n\tvoid GenerateMoveByTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation, [3] previous value for Translate usage to allow Space utilization, [4] original rotation to make sure look requests don't interfere with the direction object should move in, [5] for dial in location:\n\t\tvector3s=new Vector3[6];\n\t\t\n\t\t//grab starting rotation:\n\t\tvector3s[4] = transform.eulerAngles;\n\t\t\n\t\t//from values:\n\t\tvector3s[0]=vector3s[1]=vector3s[3]=transform.position;\n\t\t\t\t\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]=vector3s[0] + (Vector3)tweenArguments[\"amount\"];\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=vector3s[0].x + (float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=vector3s[0].y +(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=vector3s[0].z + (float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\t\n\t\t\n\t\t//calculation for dial in:\n\t\ttransform.Translate(vector3s[1],space);\n\t\tvector3s[5] = transform.position;\n\t\ttransform.position=vector3s[0];\n\t\t\n\t\t//handle orient to path request:\n\t\tif(tweenArguments.Contains(\"orienttopath\") && (bool)tweenArguments[\"orienttopath\"]){\n\t\t\ttweenArguments[\"looktarget\"] = vector3s[1];\n\t\t}\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\n\t\n\tvoid GenerateScaleToTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tvector3s=new Vector3[3];\n\t\t\n\t\t//from values:\n\t\tvector3s[0]=vector3s[1]=transform.localScale;\t\t\t\t\n\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"scale\")) {\n\t\t\tif (tweenArguments[\"scale\"].GetType() == typeof(Transform)){\n\t\t\t\tTransform trans = (Transform)tweenArguments[\"scale\"];\n\t\t\t\tvector3s[1]=trans.localScale;\t\t\t\t\t\n\t\t\t}else if(tweenArguments[\"scale\"].GetType() == typeof(Vector3)){\n\t\t\t\tvector3s[1]=(Vector3)tweenArguments[\"scale\"];\n\t\t\t}\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t} \n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\n\t\n\tvoid GenerateScaleByTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tvector3s=new Vector3[3];\n\t\t\n\t\t//from values:\n\t\tvector3s[0]=vector3s[1]=transform.localScale;\t\t\t\t\n\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]=Vector3.Scale(vector3s[1],(Vector3)tweenArguments[\"amount\"]);\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x*=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y*=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z*=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t} \n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\n\t\n\tvoid GenerateScaleAddTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tvector3s=new Vector3[3];\n\t\t\n\t\t//from values:\n\t\tvector3s[0]=vector3s[1]=transform.localScale;\t\t\t\t\n\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]+=(Vector3)tweenArguments[\"amount\"];\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x+=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y+=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z+=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\n\t\n\tvoid GenerateRotateToTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tvector3s=new Vector3[3];\n\t\t\n\t\t//from values:\n\t\tif (isLocal) {\n\t\t\tvector3s[0]=vector3s[1]=transform.localEulerAngles;\t\t\t\t\n\t\t}else{\n\t\t\tvector3s[0]=vector3s[1]=transform.eulerAngles;\n\t\t}\n\t\t\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"rotation\")) {\n\t\t\tif (tweenArguments[\"rotation\"].GetType() == typeof(Transform)){\n\t\t\t\tTransform trans = (Transform)tweenArguments[\"rotation\"];\n\t\t\t\tvector3s[1]=trans.eulerAngles;\t\t\t\n\t\t\t}else if(tweenArguments[\"rotation\"].GetType() == typeof(Vector3)){\n\t\t\t\tvector3s[1]=(Vector3)tweenArguments[\"rotation\"];\n\t\t\t}\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//shortest distance:\n\t\tvector3s[1]=new Vector3(clerp(vector3s[0].x,vector3s[1].x,1),clerp(vector3s[0].y,vector3s[1].y,1),clerp(vector3s[0].z,vector3s[1].z,1));\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\n\t\n\tvoid GenerateRotateAddTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation, [3] previous value for Rotate usage to allow Space utilization:\n\t\tvector3s=new Vector3[5];\n\t\t\n\t\t//from values:\n\t\tvector3s[0]=vector3s[1]=vector3s[3]=transform.eulerAngles;\n\t\t\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]+=(Vector3)tweenArguments[\"amount\"];\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x+=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y+=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z+=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\t\t\n\t\n\tvoid GenerateRotateByTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation, [3] previous value for Rotate usage to allow Space utilization:\n\t\tvector3s=new Vector3[4];\n\t\t\n\t\t//from values:\n\t\tvector3s[0]=vector3s[1]=vector3s[3]=transform.eulerAngles;\n\t\t\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]+=Vector3.Scale((Vector3)tweenArguments[\"amount\"],new Vector3(360,360,360));\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x+=360 * (float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y+=360 * (float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z+=360 * (float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//need for speed?\n\t\tif(tweenArguments.Contains(\"speed\")){\n\t\t\tfloat distance = Math.Abs(Vector3.Distance(vector3s[0],vector3s[1]));\n\t\t\ttime = distance/(float)tweenArguments[\"speed\"];\n\t\t}\n\t}\t\t\n\t\n\tvoid GenerateShakePositionTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation, [3] original rotation to make sure look requests don't interfere with the direction object should move in:\n\t\tvector3s=new Vector3[4];\n\t\t\n\t\t//grab starting rotation:\n\t\tvector3s[3] = transform.eulerAngles;\t\t\n\t\t\n\t\t//root:\n\t\tvector3s[0]=transform.position;\n\t\t\n\t\t//amount:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]=(Vector3)tweenArguments[\"amount\"];\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t}\t\t\n\t\n\tvoid GenerateShakeScaleTargets(){\n\t\t//values holder [0] root value, [1] amount, [2] generated amount:\n\t\tvector3s=new Vector3[3];\n\t\t\n\t\t//root:\n\t\tvector3s[0]=transform.localScale;\n\t\t\n\t\t//amount:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]=(Vector3)tweenArguments[\"amount\"];\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t}\t\t\n\t\t\n\tvoid GenerateShakeRotationTargets(){\n\t\t//values holder [0] root value, [1] amount, [2] generated amount:\n\t\tvector3s=new Vector3[3];\n\t\t\n\t\t//root:\n\t\tvector3s[0]=transform.eulerAngles;\n\t\t\n\t\t//amount:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]=(Vector3)tweenArguments[\"amount\"];\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\tvoid GeneratePunchPositionTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation, [3] previous value for Translate usage to allow Space utilization, [4] original rotation to make sure look requests don't interfere with the direction object should move in:\n\t\tvector3s=new Vector3[5];\n\t\t\n\t\t//grab starting rotation:\n\t\tvector3s[4] = transform.eulerAngles;\n\t\t\n\t\t//from values:\n\t\tvector3s[0]=transform.position;\n\t\tvector3s[1]=vector3s[3]=Vector3.zero;\n\t\t\t\t\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]=(Vector3)tweenArguments[\"amount\"];\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\tvoid GeneratePunchRotationTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation, [3] previous value for Translate usage to allow Space utilization:\n\t\tvector3s=new Vector3[4];\n\t\t\n\t\t//from values:\n\t\tvector3s[0]=transform.eulerAngles;\n\t\tvector3s[1]=vector3s[3]=Vector3.zero;\n\t\t\t\t\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]=(Vector3)tweenArguments[\"amount\"];\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t}\t\t\n\t\n\tvoid GeneratePunchScaleTargets(){\n\t\t//values holder [0] from, [1] to, [2] calculated value from ease equation:\n\t\tvector3s=new Vector3[3];\n\t\t\n\t\t//from values:\n\t\tvector3s[0]=transform.localScale;\n\t\tvector3s[1]=Vector3.zero;\n\t\t\t\t\n\t\t//to values:\n\t\tif (tweenArguments.Contains(\"amount\")) {\n\t\t\tvector3s[1]=(Vector3)tweenArguments[\"amount\"];\n\t\t}else{\n\t\t\tif (tweenArguments.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)tweenArguments[\"x\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)tweenArguments[\"y\"];\n\t\t\t}\n\t\t\tif (tweenArguments.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)tweenArguments[\"z\"];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t#endregion\n\t\n\t#region #4 Apply Targets\n\t\n\tvoid ApplyRectTargets(){\n\t\t//calculate:\n\t\trects[2].x = ease(rects[0].x,rects[1].x,percentage);\n\t\trects[2].y = ease(rects[0].y,rects[1].y,percentage);\n\t\trects[2].width = ease(rects[0].width,rects[1].width,percentage);\n\t\trects[2].height = ease(rects[0].height,rects[1].height,percentage);\n\t\t\n\t\t//apply:\n\t\ttweenArguments[\"onupdateparams\"]=rects[2];\n\t\t\n\t\t//dial in:\n\t\tif(percentage==1){\n\t\t\ttweenArguments[\"onupdateparams\"]=rects[1];\n\t\t}\n\t}\t\t\n\t\n\tvoid ApplyColorTargets(){\n\t\t//calculate:\n\t\tcolors[0,2].r = ease(colors[0,0].r,colors[0,1].r,percentage);\n\t\tcolors[0,2].g = ease(colors[0,0].g,colors[0,1].g,percentage);\n\t\tcolors[0,2].b = ease(colors[0,0].b,colors[0,1].b,percentage);\n\t\tcolors[0,2].a = ease(colors[0,0].a,colors[0,1].a,percentage);\n\t\t\n\t\t//apply:\n\t\ttweenArguments[\"onupdateparams\"]=colors[0,2];\n\t\t\n\t\t//dial in:\n\t\tif(percentage==1){\n\t\t\ttweenArguments[\"onupdateparams\"]=colors[0,1];\n\t\t}\n\t}\t\n\t\t\n\tvoid ApplyVector3Targets(){\n\t\t//calculate:\n\t\tvector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);\n\t\tvector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);\n\t\tvector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);\n\t\t\n\t\t//apply:\n\t\ttweenArguments[\"onupdateparams\"]=vector3s[2];\n\t\t\n\t\t//dial in:\n\t\tif(percentage==1){\n\t\t\ttweenArguments[\"onupdateparams\"]=vector3s[1];\n\t\t}\n\t}\t\t\n\t\n\tvoid ApplyVector2Targets(){\n\t\t//calculate:\n\t\tvector2s[2].x = ease(vector2s[0].x,vector2s[1].x,percentage);\n\t\tvector2s[2].y = ease(vector2s[0].y,vector2s[1].y,percentage);\n\t\t\n\t\t//apply:\n\t\ttweenArguments[\"onupdateparams\"]=vector2s[2];\n\t\t\n\t\t//dial in:\n\t\tif(percentage==1){\n\t\t\ttweenArguments[\"onupdateparams\"]=vector2s[1];\n\t\t}\n\t}\t\n\t\n\tvoid ApplyFloatTargets(){\n\t\t//calculate:\n\t\tfloats[2] = ease(floats[0],floats[1],percentage);\n\t\t\n\t\t//apply:\n\t\ttweenArguments[\"onupdateparams\"]=floats[2];\n\t\t\n\t\t//dial in:\n\t\tif(percentage==1){\n\t\t\ttweenArguments[\"onupdateparams\"]=floats[1];\n\t\t}\n\t}\t\n\t\n\tvoid ApplyColorToTargets(){\n\t\t//calculate:\n\t\tfor (int i = 0; i < colors.GetLength(0); i++) {\n\t\t\tcolors[i,2].r = ease(colors[i,0].r,colors[i,1].r,percentage);\n\t\t\tcolors[i,2].g = ease(colors[i,0].g,colors[i,1].g,percentage);\n\t\t\tcolors[i,2].b = ease(colors[i,0].b,colors[i,1].b,percentage);\n\t\t\tcolors[i,2].a = ease(colors[i,0].a,colors[i,1].a,percentage);\n\t\t}\n\t\t/*\n\t\tcolors[2].r = ease(colors[0].r,colors[1].r,percentage);\n\t\tcolors[2].g = ease(colors[0].g,colors[1].g,percentage);\n\t\tcolors[2].b = ease(colors[0].b,colors[1].b,percentage);\n\t\tcolors[2].a = ease(colors[0].a,colors[1].a,percentage);\n\t\t*/\n\t\t\n\t\t//apply:\n\t\tif(GetComponent(typeof(GUITexture))){\n\t\t\t//guiTexture.color=colors[2];\n\t\t\tguiTexture.color=colors[0,2];\n\t\t}else if(GetComponent(typeof(GUIText))){\n\t\t\t//guiText.material.color=colors[2];\n\t\t\tguiText.material.color=colors[0,2];\n\t\t}else if(renderer){\n\t\t\t//renderer.material.color=colors[2];\n\t\t\tfor (int i = 0; i < colors.GetLength(0); i++) {\n\t\t\t\trenderer.materials[i].SetColor(namedcolorvalue.ToString(),colors[i,2]);\n\t\t\t}\n\t\t}else if(light){\n\t\t\t//light.color=colors[2];\t\n\t\t\tlight.color=colors[0,2];\n\t\t}\n\t\t\n\t\t//dial in:\n\t\tif(percentage==1){\n\t\t\tif(GetComponent(typeof(GUITexture))){\n\t\t\t\t//guiTexture.color=colors[1];\n\t\t\t\tguiTexture.color=colors[0,1];\n\t\t\t}else if(GetComponent(typeof(GUIText))){\n\t\t\t\t//guiText.material.color=colors[1];\n\t\t\t\tguiText.material.color=colors[0,1];\n\t\t\t}else if(renderer){\n\t\t\t\t//renderer.material.color=colors[1];\t\n\t\t\t\tfor (int i = 0; i < colors.GetLength(0); i++) {\n\t\t\t\t\trenderer.materials[i].SetColor(namedcolorvalue.ToString(),colors[i,1]);\n\t\t\t\t}\n\t\t\t}else if(light){\n\t\t\t\t//light.color=colors[1];\t\n\t\t\t\tlight.color=colors[0,1];\n\t\t\t}\t\t\t\n\t\t}\n\t}\t\n\t\n\tvoid ApplyAudioToTargets(){\n\t\t//calculate:\n\t\tvector2s[2].x = ease(vector2s[0].x,vector2s[1].x,percentage);\n\t\tvector2s[2].y = ease(vector2s[0].y,vector2s[1].y,percentage);\n\t\t\n\t\t//apply:\n\t\taudioSource.volume=vector2s[2].x;\n\t\taudioSource.pitch=vector2s[2].y;\n\t\t\n\t\t//dial in:\n\t\tif(percentage==1){\n\t\t\taudioSource.volume=vector2s[1].x;\n\t\t\taudioSource.pitch=vector2s[1].y;\t\n\t\t}\n\t}\t\n\t\n\tvoid ApplyStabTargets(){\n\t\t//unnecessary but here just in case\n\t}\n\t\n\tvoid ApplyMoveToPathTargets(){\n\t\tpreUpdate = transform.position;\n\t\tfloat t = ease(0,1,percentage);\n\t\tfloat lookAheadAmount;\n\t\t\n\t\t//clamp easing equation results as \"back\" will fail since overshoots aren't handled in the Catmull-Rom interpolation:\n\t\tif(isLocal){\n\t\t\ttransform.localPosition=path.Interp(Mathf.Clamp(t,0,1));\t\n\t\t}else{\n\t\t\ttransform.position=path.Interp(Mathf.Clamp(t,0,1));\t\n\t\t}\n\t\t\n\t\t//handle orient to path request:\n\t\tif(tweenArguments.Contains(\"orienttopath\") && (bool)tweenArguments[\"orienttopath\"]){\n\t\t\t\n\t\t\t//plot a point slightly ahead in the interpolation by pushing the percentage forward using the default lookahead value:\n\t\t\tfloat tLook;\n\t\t\tif(tweenArguments.Contains(\"lookahead\")){\n\t\t\t\tlookAheadAmount = (float)tweenArguments[\"lookahead\"];\n\t\t\t}else{\n\t\t\t\tlookAheadAmount = Defaults.lookAhead;\n\t\t\t}\n\t\t\t//tLook = ease(0,1,percentage+lookAheadAmount);\t\t\t\n\t\t\ttLook = ease(0,1, Mathf.Min(1f, percentage+lookAheadAmount)); \n\t\t\t\n\t\t\t//locate new leading point with a clamp as stated above:\n\t\t\t//Vector3 lookDistance = path.Interp(Mathf.Clamp(tLook,0,1)) - transform.position;\n\t\t\ttweenArguments[\"looktarget\"] = path.Interp(Mathf.Clamp(tLook,0,1));\n\t\t}\n\t\t\n\t\t//need physics?\n\t\tpostUpdate=transform.position;\n\t\tif(physics){\n\t\t\ttransform.position=preUpdate;\n\t\t\trigidbody.MovePosition(postUpdate);\n\t\t}\n\t}\n\t\n\tvoid ApplyMoveToTargets(){\n\t\t//record current:\n\t\tpreUpdate=transform.position;\n\t\t\t\n\t\t//calculate:\n\t\tvector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);\n\t\tvector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);\n\t\tvector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);\n\t\t\n\t\t//apply:\t\n\t\tif (isLocal) {\n\t\t\ttransform.localPosition=vector3s[2];\n\t\t}else{\n\t\t\ttransform.position=vector3s[2];\n\t\t}\n\t\t\t\n\t\t//dial in:\n\t\tif(percentage==1){\n\t\t\tif (isLocal) {\n\t\t\t\ttransform.localPosition=vector3s[1];\t\t\n\t\t\t}else{\n\t\t\t\ttransform.position=vector3s[1];\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t//need physics?\n\t\tpostUpdate=transform.position;\n\t\tif(physics){\n\t\t\ttransform.position=preUpdate;\n\t\t\trigidbody.MovePosition(postUpdate);\n\t\t}\n\t}\t\n\t\n\tvoid ApplyMoveByTargets(){\t\n\t\tpreUpdate = transform.position;\n\t\t\n\t\t//reset rotation to prevent look interferences as object rotates and attempts to move with translate and record current rotation\n\t\tVector3 currentRotation = new Vector3();\n\t\t\n\t\tif(tweenArguments.Contains(\"looktarget\")){\n\t\t\tcurrentRotation = transform.eulerAngles;\n\t\t\ttransform.eulerAngles = vector3s[4];\t\n\t\t}\n\t\t\n\t\t//calculate:\n\t\tvector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);\n\t\tvector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);\n\t\tvector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);\n\t\t\t\t\n\t\t//apply:\n\t\ttransform.Translate(vector3s[2]-vector3s[3],space);\n\t\t\n\t\t//record:\n\t\tvector3s[3]=vector3s[2];\n\t\t\n\t\t//reset rotation:\n\t\tif(tweenArguments.Contains(\"looktarget\")){\n\t\t\ttransform.eulerAngles = currentRotation;\t\n\t\t}\n\t\t\t\t\n\t\t/*\n\t\t//dial in:\n\t\tif(percentage==1){\t\n\t\t\ttransform.position=vector3s[5];\n\t\t}\n\t\t*/\n\t\t\n\t\t//need physics?\n\t\tpostUpdate=transform.position;\n\t\tif(physics){\n\t\t\ttransform.position=preUpdate;\n\t\t\trigidbody.MovePosition(postUpdate);\n\t\t}\n\t}\t\n\t\n\tvoid ApplyScaleToTargets(){\n\t\t//calculate:\n\t\tvector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);\n\t\tvector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);\n\t\tvector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);\n\t\t\n\t\t//apply:\n\t\ttransform.localScale=vector3s[2];\t\n\t\t\n\t\t//dial in:\n\t\tif(percentage==1){\n\t\t\ttransform.localScale=vector3s[1];\n\t\t}\n\t}\n\t\n\tvoid ApplyLookToTargets(){\n\t\t//calculate:\n\t\tvector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);\n\t\tvector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);\n\t\tvector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);\n\t\t\n\t\t//apply:\n\t\tif (isLocal) {\n\t\t\ttransform.localRotation = Quaternion.Euler(vector3s[2]);\n\t\t}else{\n\t\t\ttransform.rotation = Quaternion.Euler(vector3s[2]);\n\t\t};\t\n\t}\t\n\t\n\tvoid ApplyRotateToTargets(){\n\t\tpreUpdate=transform.eulerAngles;\n\t\t\n\t\t//calculate:\n\t\tvector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);\n\t\tvector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);\n\t\tvector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);\n\t\t\n\t\t//apply:\n\t\tif (isLocal) {\n\t\t\ttransform.localRotation = Quaternion.Euler(vector3s[2]);\n\t\t}else{\n\t\t\ttransform.rotation = Quaternion.Euler(vector3s[2]);\n\t\t};\t\n\t\t\n\t\t//dial in:\n\t\tif(percentage==1){\n\t\t\tif (isLocal) {\n\t\t\t\ttransform.localRotation = Quaternion.Euler(vector3s[1]);\n\t\t\t}else{\n\t\t\t\ttransform.rotation = Quaternion.Euler(vector3s[1]);\n\t\t\t};\n\t\t}\n\t\t\n\t\t//need physics?\n\t\tpostUpdate=transform.eulerAngles;\n\t\tif(physics){\n\t\t\ttransform.eulerAngles=preUpdate;\n\t\t\trigidbody.MoveRotation(Quaternion.Euler(postUpdate));\n\t\t}\n\t}\n\t\n\tvoid ApplyRotateAddTargets(){\n\t\tpreUpdate = transform.eulerAngles;\n\t\t\n\t\t//calculate:\n\t\tvector3s[2].x = ease(vector3s[0].x,vector3s[1].x,percentage);\n\t\tvector3s[2].y = ease(vector3s[0].y,vector3s[1].y,percentage);\n\t\tvector3s[2].z = ease(vector3s[0].z,vector3s[1].z,percentage);\n\t\t\n\t\t//apply:\n\t\ttransform.Rotate(vector3s[2]-vector3s[3],space);\n\n\t\t//record:\n\t\tvector3s[3]=vector3s[2];\t\n\t\t\n\t\t//need physics?\n\t\tpostUpdate=transform.eulerAngles;\n\t\tif(physics){\n\t\t\ttransform.eulerAngles=preUpdate;\n\t\t\trigidbody.MoveRotation(Quaternion.Euler(postUpdate));\n\t\t}\t\t\n\t}\t\n\t\n\tvoid ApplyShakePositionTargets(){\n\t\t//preUpdate = transform.position;\n\t\tif (isLocal) {\n\t\t\tpreUpdate = transform.localPosition;\n\t\t}else{\n\t\t\tpreUpdate = transform.position;\n\t\t}\n\t\t\n\t\t//reset rotation to prevent look interferences as object rotates and attempts to move with translate and record current rotation\n\t\tVector3 currentRotation = new Vector3();\n\t\t\n\t\tif(tweenArguments.Contains(\"looktarget\")){\n\t\t\tcurrentRotation = transform.eulerAngles;\n\t\t\ttransform.eulerAngles = vector3s[3];\t\n\t\t}\n\t\t\n\t\t//impact:\n\t\tif (percentage==0) {\n\t\t\ttransform.Translate(vector3s[1],space);\n\t\t}\n\t\t\n\t\t//transform.position=vector3s[0];\n\t\t//reset:\n\t\tif (isLocal) {\n\t\t\ttransform.localPosition=vector3s[0];\n\t\t}else{\n\t\t\ttransform.position=vector3s[0];\n\t\t}\n\t\t\n\t\t//generate:\n\t\tfloat diminishingControl = 1-percentage;\n\t\tvector3s[2].x= UnityEngine.Random.Range(-vector3s[1].x*diminishingControl, vector3s[1].x*diminishingControl);\n\t\tvector3s[2].y= UnityEngine.Random.Range(-vector3s[1].y*diminishingControl, vector3s[1].y*diminishingControl);\n\t\tvector3s[2].z= UnityEngine.Random.Range(-vector3s[1].z*diminishingControl, vector3s[1].z*diminishingControl);\n\n\t\t//apply:\t\n\t\t//transform.Translate(vector3s[2],space);\t\n\t\tif (isLocal) {\n\t\t\ttransform.localPosition+=vector3s[2];\n\t\t}else{\n\t\t\ttransform.position+=vector3s[2];\n\t\t}\n\t\t\n\t\t//reset rotation:\n\t\tif(tweenArguments.Contains(\"looktarget\")){\n\t\t\ttransform.eulerAngles = currentRotation;\t\n\t\t}\t\n\t\t\n\t\t//need physics?\n\t\tpostUpdate=transform.position;\n\t\tif(physics){\n\t\t\ttransform.position=preUpdate;\n\t\t\trigidbody.MovePosition(postUpdate);\n\t\t}\n\t}\t\n\t\n\tvoid ApplyShakeScaleTargets(){\n\t\t//impact:\n\t\tif (percentage==0) {\n\t\t\ttransform.localScale=vector3s[1];\n\t\t}\n\t\t\n\t\t//reset:\n\t\ttransform.localScale=vector3s[0];\n\t\t\n\t\t//generate:\n\t\tfloat diminishingControl = 1-percentage;\n\t\tvector3s[2].x= UnityEngine.Random.Range(-vector3s[1].x*diminishingControl, vector3s[1].x*diminishingControl);\n\t\tvector3s[2].y= UnityEngine.Random.Range(-vector3s[1].y*diminishingControl, vector3s[1].y*diminishingControl);\n\t\tvector3s[2].z= UnityEngine.Random.Range(-vector3s[1].z*diminishingControl, vector3s[1].z*diminishingControl);\n\n\t\t//apply:\n\t\ttransform.localScale+=vector3s[2];\n\t}\t\t\n\t\n\tvoid ApplyShakeRotationTargets(){\n\t\tpreUpdate = transform.eulerAngles;\n\t\t\n\t\t//impact:\n\t\tif (percentage==0) {\n\t\t\ttransform.Rotate(vector3s[1],space);\n\t\t}\n\t\t\n\t\t//reset:\n\t\ttransform.eulerAngles=vector3s[0];\n\t\t\n\t\t//generate:\n\t\tfloat diminishingControl = 1-percentage;\n\t\tvector3s[2].x= UnityEngine.Random.Range(-vector3s[1].x*diminishingControl, vector3s[1].x*diminishingControl);\n\t\tvector3s[2].y= UnityEngine.Random.Range(-vector3s[1].y*diminishingControl, vector3s[1].y*diminishingControl);\n\t\tvector3s[2].z= UnityEngine.Random.Range(-vector3s[1].z*diminishingControl, vector3s[1].z*diminishingControl);\n\n\t\t//apply:\n\t\ttransform.Rotate(vector3s[2],space);\n\t\t\n\t\t//need physics?\n\t\tpostUpdate=transform.eulerAngles;\n\t\tif(physics){\n\t\t\ttransform.eulerAngles=preUpdate;\n\t\t\trigidbody.MoveRotation(Quaternion.Euler(postUpdate));\n\t\t}\n\t}\t\t\n\t\n\tvoid ApplyPunchPositionTargets(){\n\t\tpreUpdate = transform.position;\n\t\t\n\t\t//reset rotation to prevent look interferences as object rotates and attempts to move with translate and record current rotation\n\t\tVector3 currentRotation = new Vector3();\n\t\t\n\t\tif(tweenArguments.Contains(\"looktarget\")){\n\t\t\tcurrentRotation = transform.eulerAngles;\n\t\t\ttransform.eulerAngles = vector3s[4];\t\n\t\t}\n\t\t\n\t\t//calculate:\n\t\tif(vector3s[1].x>0){\n\t\t\tvector3s[2].x = punch(vector3s[1].x,percentage);\n\t\t}else if(vector3s[1].x<0){\n\t\t\tvector3s[2].x=-punch(Mathf.Abs(vector3s[1].x),percentage); \n\t\t}\n\t\tif(vector3s[1].y>0){\n\t\t\tvector3s[2].y=punch(vector3s[1].y,percentage);\n\t\t}else if(vector3s[1].y<0){\n\t\t\tvector3s[2].y=-punch(Mathf.Abs(vector3s[1].y),percentage); \n\t\t}\n\t\tif(vector3s[1].z>0){\n\t\t\tvector3s[2].z=punch(vector3s[1].z,percentage);\n\t\t}else if(vector3s[1].z<0){\n\t\t\tvector3s[2].z=-punch(Mathf.Abs(vector3s[1].z),percentage); \n\t\t}\n\t\t\n\t\t//apply:\n\t\ttransform.Translate(vector3s[2]-vector3s[3],space);\n\n\t\t//record:\n\t\tvector3s[3]=vector3s[2];\n\t\t\n\t\t//reset rotation:\n\t\tif(tweenArguments.Contains(\"looktarget\")){\n\t\t\ttransform.eulerAngles = currentRotation;\t\n\t\t}\n\t\t\n\t\t//dial in:\n\t\t/*\n\t\tif(percentage==1){\t\n\t\t\ttransform.position=vector3s[0];\n\t\t}\n\t\t*/\n\t\t\n\t\t//need physics?\n\t\tpostUpdate=transform.position;\n\t\tif(physics){\n\t\t\ttransform.position=preUpdate;\n\t\t\trigidbody.MovePosition(postUpdate);\n\t\t}\n\t}\t\t\n\t\n\tvoid ApplyPunchRotationTargets(){\n\t\tpreUpdate = transform.eulerAngles;\n\t\t\n\t\t//calculate:\n\t\tif(vector3s[1].x>0){\n\t\t\tvector3s[2].x = punch(vector3s[1].x,percentage);\n\t\t}else if(vector3s[1].x<0){\n\t\t\tvector3s[2].x=-punch(Mathf.Abs(vector3s[1].x),percentage); \n\t\t}\n\t\tif(vector3s[1].y>0){\n\t\t\tvector3s[2].y=punch(vector3s[1].y,percentage);\n\t\t}else if(vector3s[1].y<0){\n\t\t\tvector3s[2].y=-punch(Mathf.Abs(vector3s[1].y),percentage); \n\t\t}\n\t\tif(vector3s[1].z>0){\n\t\t\tvector3s[2].z=punch(vector3s[1].z,percentage);\n\t\t}else if(vector3s[1].z<0){\n\t\t\tvector3s[2].z=-punch(Mathf.Abs(vector3s[1].z),percentage); \n\t\t}\n\t\t\n\t\t//apply:\n\t\ttransform.Rotate(vector3s[2]-vector3s[3],space);\n\n\t\t//record:\n\t\tvector3s[3]=vector3s[2];\n\t\t\n\t\t//dial in:\n\t\t/*\n\t\tif(percentage==1){\t\n\t\t\ttransform.eulerAngles=vector3s[0];\n\t\t}\n\t\t*/\n\t\t\n\t\t//need physics?\n\t\tpostUpdate=transform.eulerAngles;\n\t\tif(physics){\n\t\t\ttransform.eulerAngles=preUpdate;\n\t\t\trigidbody.MoveRotation(Quaternion.Euler(postUpdate));\n\t\t}\n\t}\t\n\t\n\tvoid ApplyPunchScaleTargets(){\n\t\t//calculate:\n\t\tif(vector3s[1].x>0){\n\t\t\tvector3s[2].x = punch(vector3s[1].x,percentage);\n\t\t}else if(vector3s[1].x<0){\n\t\t\tvector3s[2].x=-punch(Mathf.Abs(vector3s[1].x),percentage); \n\t\t}\n\t\tif(vector3s[1].y>0){\n\t\t\tvector3s[2].y=punch(vector3s[1].y,percentage);\n\t\t}else if(vector3s[1].y<0){\n\t\t\tvector3s[2].y=-punch(Mathf.Abs(vector3s[1].y),percentage); \n\t\t}\n\t\tif(vector3s[1].z>0){\n\t\t\tvector3s[2].z=punch(vector3s[1].z,percentage);\n\t\t}else if(vector3s[1].z<0){\n\t\t\tvector3s[2].z=-punch(Mathf.Abs(vector3s[1].z),percentage); \n\t\t}\n\t\t\n\t\t//apply:\n\t\ttransform.localScale=vector3s[0]+vector3s[2];\n\t\t\n\t\t//dial in:\n\t\t/*\n\t\tif(percentage==1){\t\n\t\t\ttransform.localScale=vector3s[0];\n\t\t}\n\t\t*/\n\t}\t\t\n\t\n\t#endregion\t\n\t\n\t#region #5 Tween Steps\n\t\n\tIEnumerator TweenDelay(){\n\t\tdelayStarted = Time.time;\n\t\tyield return new WaitForSeconds (delay);\n\t\tif(wasPaused){\n\t\t\twasPaused=false;\n\t\t\tTweenStart();\t\n\t\t}\n\t}\t\n\t\n\tvoid TweenStart(){\t\t\n\t\tCallBack(\"onstart\");\n\t\t\n\t\tif(!loop){//only if this is not a loop\n\t\t\tConflictCheck();\n\t\t\tGenerateTargets();\n\t\t}\n\t\t\t\t\n\t\t//run stab:\n\t\tif(type == \"stab\"){\n\t\t\taudioSource.PlayOneShot(audioSource.clip);\n\t\t}\n\t\t\n\t\t//toggle isKinematic for iTweens that may interfere with physics:\n\t\tif (type == \"move\" || type==\"scale\" || type==\"rotate\" || type==\"punch\" || type==\"shake\" || type==\"curve\" || type==\"look\") {\n\t\t\tEnableKinematic();\n\t\t}\n\t\t\n\t\tisRunning = true;\n\t}\n\t\n\tIEnumerator TweenRestart(){\n\t\tif(delay > 0){\n\t\t\tdelayStarted = Time.time;\n\t\t\tyield return new WaitForSeconds (delay);\n\t\t}\n\t\tloop=true;\n\t\tTweenStart();\n\t}\t\n\t\n\tvoid TweenUpdate(){\n\t\tapply();\n\t\tCallBack(\"onupdate\");\n\t\tUpdatePercentage();\t\t\n\t}\n\t\t\t\n\tvoid TweenComplete(){\n\t\tisRunning=false;\n\t\t\n\t\t//dial in percentage to 1 or 0 for final run:\n\t\tif(percentage>.5f){\n\t\t\tpercentage=1f;\n\t\t}else{\n\t\t\tpercentage=0;\t\n\t\t}\n\t\t\n\t\t//apply dial in and final run:\n\t\tapply();\n\t\tif(type == \"value\"){\n\t\t\tCallBack(\"onupdate\"); //CallBack run for ValueTo since it only calculates and applies in the update callback\n\t\t}\n\t\t\n\t\t//loop or dispose?\n\t\tif(loopType==LoopType.none){\n\t\t\tDispose();\n\t\t}else{\n\t\t\tTweenLoop();\n\t\t}\n\t\t\n\t\tCallBack(\"oncomplete\");\n\t}\n\t\n\tvoid TweenLoop(){\n\t\tDisableKinematic(); //give physics control again\n\t\tswitch(loopType){\n\t\t\tcase LoopType.loop:\n\t\t\t\t//rewind:\n\t\t\t\tpercentage=0;\n\t\t\t\trunningTime=0;\n\t\t\t\tapply();\n\t\t\t\t\n\t\t\t\t//replay:\n\t\t\t\tStartCoroutine(\"TweenRestart\");\n\t\t\t\tbreak;\n\t\t\tcase LoopType.pingPong:\n\t\t\t\treverse = !reverse;\n\t\t\t\trunningTime=0;\n\t\t\t\n\t\t\t\t//replay:\n\t\t\t\tStartCoroutine(\"TweenRestart\");\n\t\t\t\tbreak;\n\t\t}\n\t}\t\n\t\n\t#endregion\n\t\n\t#region #6 Update Callable\n\t\n\t/// <summary>\n\t/// Returns a Rect that is eased between a current and target value by the supplied speed.\n\t/// </summary>\n\t/// <returns>\n\t/// A <see cref=\"Rect\"/\n\t/// </returns>\n\t/// <param name='currentValue'>\n\t/// A <see cref=\"Rect\"/> the starting or initial value\n\t/// </param>\n\t/// <param name='targetValue'>\n\t/// A <see cref=\"Rect\"/> the target value that the current value will be eased to.\n\t/// </param>\n\t/// <param name='speed'>\n\t/// A <see cref=\"System.Single\"/> to be used as rate of speed (larger number equals faster animation)\n\t/// </param>\n\tpublic static Rect RectUpdate(Rect currentValue, Rect targetValue, float speed){\n\t\tRect diff = new Rect(FloatUpdate(currentValue.x, targetValue.x, speed), FloatUpdate(currentValue.y, targetValue.y, speed), FloatUpdate(currentValue.width, targetValue.width, speed), FloatUpdate(currentValue.height, targetValue.height, speed));\n\t\treturn (diff);\n\t}\n\t\n\t/// <summary>\n\t/// Returns a Vector3 that is eased between a current and target value by the supplied speed.\n\t/// </summary>\n\t/// <returns>\n\t/// A <see cref=\"Vector3\"/>\n\t/// </returns>\n\t/// <param name='currentValue'>\n\t/// A <see cref=\"Vector3\"/> the starting or initial value\n\t/// </param>\n\t/// <param name='targetValue'>\n\t/// A <see cref=\"Vector3\"/> the target value that the current value will be eased to.\n\t/// </param>\n\t/// <param name='speed'>\n\t/// A <see cref=\"System.Single\"/> to be used as rate of speed (larger number equals faster animation)\n\t/// </param>\n\tpublic static Vector3 Vector3Update(Vector3 currentValue, Vector3 targetValue, float speed){\n\t\tVector3 diff = targetValue - currentValue;\n\t\tcurrentValue += (diff * speed) * Time.deltaTime;\n\t\treturn (currentValue);\n\t}\n\t\n\t/// <summary>\n\t/// Returns a Vector2 that is eased between a current and target value by the supplied speed.\n\t/// </summary>\n\t/// <returns>\n\t/// A <see cref=\"Vector2\"/>\n\t/// </returns>\n\t/// <param name='currentValue'>\n\t/// A <see cref=\"Vector2\"/> the starting or initial value\n\t/// </param>\n\t/// <param name='targetValue'>\n\t/// A <see cref=\"Vector2\"/> the target value that the current value will be eased to.\n\t/// </param>\n\t/// <param name='speed'>\n\t/// A <see cref=\"System.Single\"/> to be used as rate of speed (larger number equals faster animation)\n\t/// </param>\n\tpublic static Vector2 Vector2Update(Vector2 currentValue, Vector2 targetValue, float speed){\n\t\tVector2 diff = targetValue - currentValue;\n\t\tcurrentValue += (diff * speed) * Time.deltaTime;\n\t\treturn (currentValue);\n\t}\n\t\n\t/// <summary>\n\t/// Returns a float that is eased between a current and target value by the supplied speed.\n\t/// </summary>\n\t/// <returns>\n\t/// A <see cref=\"System.Single\"/>\n\t/// </returns>\n\t/// <param name='currentValue'>\n\t/// A <see cref=\"System.Single\"/> the starting or initial value\n\t/// </param>\n\t/// <param name='targetValue'>\n\t/// A <see cref=\"System.Single\"/> the target value that the current value will be eased to.\n\t/// </param>\n\t/// <param name='speed'>\n\t/// A <see cref=\"System.Single\"/> to be used as rate of speed (larger number equals faster animation)\n\t/// </param>\n\tpublic static float FloatUpdate(float currentValue, float targetValue, float speed){\n\t\tfloat diff = targetValue - currentValue;\n\t\tcurrentValue += (diff * speed) * Time.deltaTime;\n\t\treturn (currentValue);\n\t}\n\t\n\t/// <summary>\n\t/// Similar to FadeTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with FULL customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"alpha\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the final alpha value of the animation.\n\t/// </param>\n\t/// <param name=\"includechildren\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not to include children of this GameObject. True by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void FadeUpdate(GameObject target, Hashtable args){\n\t\targs[\"a\"]=args[\"alpha\"];\n\t\tColorUpdate(target,args);\n\t}\n\t\n\t/// <summary>\n\t/// Similar to FadeTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with MINIMUM customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"alpha\">\n\t/// A <see cref=\"System.Single\"/> for the final alpha value of the animation.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void FadeUpdate(GameObject target, float alpha, float time){\n\t\tFadeUpdate(target,Hash(\"alpha\",alpha,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Similar to ColorTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with FULL customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/> to change the GameObject's color to.\n\t/// </param>\n\t/// <param name=\"r\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the color red.\n\t/// </param>\n\t/// <param name=\"g\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the color green.\n\t/// </param>\n\t/// <param name=\"b\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the color green.\n\t/// </param>\n\t/// <param name=\"a\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the alpha.\n\t/// </param> \n\t/// <param name=\"namedcolorvalue\">\n\t/// A <see cref=\"NamedColorValue\"/> or <see cref=\"System.String\"/> for the individual setting of the alpha.\n\t/// </param> \n\t/// <param name=\"includechildren\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not to include children of this GameObject. True by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ColorUpdate(GameObject target, Hashtable args){\n\t\tCleanArgs(args);\n\t\t\n\t\tfloat time;\n\t\tColor[] colors = new Color[4];\n\t\t\n\t\t//handle children:\n\t\tif(!args.Contains(\"includechildren\") || (bool)args[\"includechildren\"]){\n\t\t\tforeach(Transform child in target.transform){\n\t\t\t\tColorUpdate(child.gameObject,args);\n\t\t\t}\n\t\t}\t\t \n\t\t\n\t\t//set smooth time:\n\t\tif(args.Contains(\"time\")){\n\t\t\ttime=(float)args[\"time\"];\n\t\t\ttime*=Defaults.updateTimePercentage;\n\t\t}else{\n\t\t\ttime=Defaults.updateTime;\n\t\t}\n\t\t\n\t\t//init values:\n\t\tif(target.GetComponent(typeof(GUITexture))){\n\t\t\tcolors[0] = colors[1] = target.guiTexture.color;\n\t\t}else if(target.GetComponent(typeof(GUIText))){\n\t\t\tcolors[0] = colors[1] = target.guiText.material.color;\n\t\t}else if(target.renderer){\n\t\t\tcolors[0] = colors[1] = target.renderer.material.color;\n\t\t}else if(target.light){\n\t\t\tcolors[0] = colors[1] = target.light.color;\t\n\t\t}\t\t\n\t\t\n\t\t//to values:\n\t\tif (args.Contains(\"color\")) {\n\t\t\tcolors[1]=(Color)args[\"color\"];\n\t\t}else{\n\t\t\tif (args.Contains(\"r\")) {\n\t\t\t\tcolors[1].r=(float)args[\"r\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"g\")) {\n\t\t\t\tcolors[1].g=(float)args[\"g\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"b\")) {\n\t\t\t\tcolors[1].b=(float)args[\"b\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"a\")) {\n\t\t\t\tcolors[1].a=(float)args[\"a\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//calculate:\n\t\tcolors[3].r=Mathf.SmoothDamp(colors[0].r,colors[1].r,ref colors[2].r,time);\n\t\tcolors[3].g=Mathf.SmoothDamp(colors[0].g,colors[1].g,ref colors[2].g,time);\n\t\tcolors[3].b=Mathf.SmoothDamp(colors[0].b,colors[1].b,ref colors[2].b,time);\n\t\tcolors[3].a=Mathf.SmoothDamp(colors[0].a,colors[1].a,ref colors[2].a,time);\n\t\t\t\t\n\t\t//apply:\n\t\tif(target.GetComponent(typeof(GUITexture))){\n\t\t\ttarget.guiTexture.color=colors[3];\n\t\t}else if(target.GetComponent(typeof(GUIText))){\n\t\t\ttarget.guiText.material.color=colors[3];\n\t\t}else if(target.renderer){\n\t\t\ttarget.renderer.material.color=colors[3];\n\t\t}else if(target.light){\n\t\t\ttarget.light.color=colors[3];\t\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Similar to ColorTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with MINIMUM customization options. Does not utilize an EaseType.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/> to change the GameObject's color to.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ColorUpdate(GameObject target, Color color, float time){\n\t\tColorUpdate(target,Hash(\"color\",color,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Similar to AudioTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with FULL customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"audiosource\">\n\t/// A <see cref=\"AudioSource\"/> for which AudioSource to use.\n\t/// </param> \n\t/// <param name=\"volume\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the target level of volume.\n\t/// </param>\n\t/// <param name=\"pitch\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the target pitch.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void AudioUpdate(GameObject target, Hashtable args){\n\t\tCleanArgs(args);\n\t\t\n\t\tAudioSource audioSource;\n\t\tfloat time;\n\t\tVector2[] vector2s = new Vector2[4];\n\t\t\t\n\t\t//set smooth time:\n\t\tif(args.Contains(\"time\")){\n\t\t\ttime=(float)args[\"time\"];\n\t\t\ttime*=Defaults.updateTimePercentage;\n\t\t}else{\n\t\t\ttime=Defaults.updateTime;\n\t\t}\n\n\t\t//set audioSource:\n\t\tif(args.Contains(\"audiosource\")){\n\t\t\taudioSource=(AudioSource)args[\"audiosource\"];\n\t\t}else{\n\t\t\tif(target.GetComponent(typeof(AudioSource))){\n\t\t\t\taudioSource=target.audio;\n\t\t\t}else{\n\t\t\t\t//throw error if no AudioSource is available:\n\t\t\t\tDebug.LogError(\"iTween Error: AudioUpdate requires an AudioSource.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\t//from values:\n\t\tvector2s[0] = vector2s[1] = new Vector2(audioSource.volume,audioSource.pitch);\n\t\t\n\t\t//set to:\n\t\tif(args.Contains(\"volume\")){\n\t\t\tvector2s[1].x=(float)args[\"volume\"];\n\t\t}\n\t\tif(args.Contains(\"pitch\")){\n\t\t\tvector2s[1].y=(float)args[\"pitch\"];\n\t\t}\n\t\t\n\t\t//calculate:\n\t\tvector2s[3].x=Mathf.SmoothDampAngle(vector2s[0].x,vector2s[1].x,ref vector2s[2].x,time);\n\t\tvector2s[3].y=Mathf.SmoothDampAngle(vector2s[0].y,vector2s[1].y,ref vector2s[2].y,time);\n\t\n\t\t//apply:\n\t\taudioSource.volume=vector2s[3].x;\n\t\taudioSource.pitch=vector2s[3].y;\n\t}\n\t\n\t/// <summary>\n\t/// Similar to AudioTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with MINIMUM customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"volume\">\n\t/// A <see cref=\"System.Single\"/> for the target level of volume.\n\t/// </param>\n\t/// <param name=\"pitch\">\n\t/// A <see cref=\"System.Single\"/> for the target pitch.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void AudioUpdate(GameObject target, float volume, float pitch, float time){\n\t\tAudioUpdate(target,Hash(\"volume\",volume,\"pitch\",pitch,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Similar to RotateTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with FULL customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"rotation\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for the target Euler angles in degrees to rotate to.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"islocal\">\n\t/// A <see cref=\"System.Boolean\"/> for whether to animate in world space or relative to the parent. False by default.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param> \n\tpublic static void RotateUpdate(GameObject target, Hashtable args){\n\t\tCleanArgs(args);\n\t\t\n\t\tbool isLocal;\n\t\tfloat time;\n\t\tVector3[] vector3s = new Vector3[4];\n\t\tVector3 preUpdate = target.transform.eulerAngles;\n\t\t\n\t\t//set smooth time:\n\t\tif(args.Contains(\"time\")){\n\t\t\ttime=(float)args[\"time\"];\n\t\t\ttime*=Defaults.updateTimePercentage;\n\t\t}else{\n\t\t\ttime=Defaults.updateTime;\n\t\t}\n\t\t\n\t\t//set isLocal:\n\t\tif(args.Contains(\"islocal\")){\n\t\t\tisLocal = (bool)args[\"islocal\"];\n\t\t}else{\n\t\t\tisLocal = Defaults.isLocal;\t\n\t\t}\n\t\t\n\t\t//from values:\n\t\tif(isLocal){\n\t\t\tvector3s[0] = target.transform.localEulerAngles;\n\t\t}else{\n\t\t\tvector3s[0] = target.transform.eulerAngles;\t\n\t\t}\n\t\t\n\t\t//set to:\n\t\tif(args.Contains(\"rotation\")){\n\t\t\tif (args[\"rotation\"].GetType() == typeof(Transform)){\n\t\t\t\tTransform trans = (Transform)args[\"rotation\"];\n\t\t\t\tvector3s[1]=trans.eulerAngles;\n\t\t\t}else if(args[\"rotation\"].GetType() == typeof(Vector3)){\n\t\t\t\tvector3s[1]=(Vector3)args[\"rotation\"];\n\t\t\t}\t\n\t\t}\n\t\t\t\t\n\t\t//calculate:\n\t\tvector3s[3].x=Mathf.SmoothDampAngle(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);\n\t\tvector3s[3].y=Mathf.SmoothDampAngle(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);\n\t\tvector3s[3].z=Mathf.SmoothDampAngle(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);\n\t\n\t\t//apply:\n\t\tif(isLocal){\n\t\t\ttarget.transform.localEulerAngles=vector3s[3];\n\t\t}else{\n\t\t\ttarget.transform.eulerAngles=vector3s[3];\n\t\t}\n\t\t\n\t\t//need physics?\n\t\tif(target.rigidbody != null){\n\t\t\tVector3 postUpdate=target.transform.eulerAngles;\n\t\t\ttarget.transform.eulerAngles=preUpdate;\n\t\t\ttarget.rigidbody.MoveRotation(Quaternion.Euler(postUpdate));\n\t\t}\n\t}\n\t\t\n\t/// <summary>\n\t/// Similar to RotateTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with MINIMUM customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"rotation\">\n\t/// A <see cref=\"Vector3\"/> for the target Euler angles in degrees to rotate to.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void RotateUpdate(GameObject target, Vector3 rotation, float time){\n\t\tRotateUpdate(target,Hash(\"rotation\",rotation,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Similar to ScaleTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with FULL customization options.  Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"scale\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for the final scale.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param> \n\tpublic static void ScaleUpdate(GameObject target, Hashtable args){\n\t\tCleanArgs(args);\n\t\t\n\t\tfloat time;\n\t\tVector3[] vector3s = new Vector3[4];\n\t\t\t\n\t\t//set smooth time:\n\t\tif(args.Contains(\"time\")){\n\t\t\ttime=(float)args[\"time\"];\n\t\t\ttime*=Defaults.updateTimePercentage;\n\t\t}else{\n\t\t\ttime=Defaults.updateTime;\n\t\t}\n\t\t\n\t\t//init values:\n\t\tvector3s[0] = vector3s[1] = target.transform.localScale;\n\t\t\n\t\t//to values:\n\t\tif (args.Contains(\"scale\")) {\n\t\t\tif (args[\"scale\"].GetType() == typeof(Transform)){\n\t\t\t\tTransform trans = (Transform)args[\"scale\"];\n\t\t\t\tvector3s[1]=trans.localScale;\n\t\t\t}else if(args[\"scale\"].GetType() == typeof(Vector3)){\n\t\t\t\tvector3s[1]=(Vector3)args[\"scale\"];\n\t\t\t}\t\t\t\t\n\t\t}else{\n\t\t\tif (args.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)args[\"x\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)args[\"y\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)args[\"z\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//calculate:\n\t\tvector3s[3].x=Mathf.SmoothDamp(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);\n\t\tvector3s[3].y=Mathf.SmoothDamp(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);\n\t\tvector3s[3].z=Mathf.SmoothDamp(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);\n\t\t\t\t\n\t\t//apply:\n\t\ttarget.transform.localScale=vector3s[3];\t\t\n\t}\t\n\t\n\t/// <summary>\n\t/// Similar to ScaleTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with MINIMUM customization options.  Does not utilize an EaseType.\n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"scale\">\n\t/// A <see cref=\"Vector3\"/> for the final scale.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void ScaleUpdate(GameObject target, Vector3 scale, float time){\n\t\tScaleUpdate(target,Hash(\"scale\",scale,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Similar to MoveTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with FULL customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"position\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for a point in space the GameObject will animate to.\n\t/// </param>\n\t/// <param name=\"x\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the x axis.\n\t/// </param>\n\t/// <param name=\"y\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the y axis.\n\t/// </param>\n\t/// <param name=\"z\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the individual setting of the z axis.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param> \n\t/// <param name=\"islocal\">\n\t/// A <see cref=\"System.Boolean\"/> for whether to animate in world space or relative to the parent. False by default.\n\t/// </param>\n\t/// <param name=\"orienttopath\">\n\t/// A <see cref=\"System.Boolean\"/> for whether or not the GameObject will orient to its direction of travel.  False by default.\n\t/// </param>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Vector3\"/> or A <see cref=\"Transform\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"looktime\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the object will take to look at either the \"looktarget\" or \"orienttopath\".\n\t/// </param>\n\t/// <param name=\"axis\">\n\t/// A <see cref=\"System.String\"/>. Restricts rotation to the supplied axis only.\n\t/// </param>\n\tpublic static void MoveUpdate(GameObject target, Hashtable args){\n\t\tCleanArgs(args);\n\t\t\n\t\tfloat time;\n\t\tVector3[] vector3s = new Vector3[4];\n\t\tbool isLocal;\n\t\tVector3 preUpdate = target.transform.position;\n\t\t\t\n\t\t//set smooth time:\n\t\tif(args.Contains(\"time\")){\n\t\t\ttime=(float)args[\"time\"];\n\t\t\ttime*=Defaults.updateTimePercentage;\n\t\t}else{\n\t\t\ttime=Defaults.updateTime;\n\t\t}\n\t\t\t\n\t\t//set isLocal:\n\t\tif(args.Contains(\"islocal\")){\n\t\t\tisLocal = (bool)args[\"islocal\"];\n\t\t}else{\n\t\t\tisLocal = Defaults.isLocal;\t\n\t\t}\n\t\t \n\t\t//init values:\n\t\tif(isLocal){\n\t\t\tvector3s[0] = vector3s[1] = target.transform.localPosition;\n\t\t}else{\n\t\t\tvector3s[0] = vector3s[1] = target.transform.position;\t\n\t\t}\n\t\t\n\t\t//to values:\n\t\tif (args.Contains(\"position\")) {\n\t\t\tif (args[\"position\"].GetType() == typeof(Transform)){\n\t\t\t\tTransform trans = (Transform)args[\"position\"];\n\t\t\t\tvector3s[1]=trans.position;\n\t\t\t}else if(args[\"position\"].GetType() == typeof(Vector3)){\n\t\t\t\tvector3s[1]=(Vector3)args[\"position\"];\n\t\t\t}\t\t\t\n\t\t}else{\n\t\t\tif (args.Contains(\"x\")) {\n\t\t\t\tvector3s[1].x=(float)args[\"x\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"y\")) {\n\t\t\t\tvector3s[1].y=(float)args[\"y\"];\n\t\t\t}\n\t\t\tif (args.Contains(\"z\")) {\n\t\t\t\tvector3s[1].z=(float)args[\"z\"];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//calculate:\n\t\tvector3s[3].x=Mathf.SmoothDamp(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);\n\t\tvector3s[3].y=Mathf.SmoothDamp(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);\n\t\tvector3s[3].z=Mathf.SmoothDamp(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);\n\t\t\t\n\t\t//handle orient to path:\n\t\tif(args.Contains(\"orienttopath\") && (bool)args[\"orienttopath\"]){\n\t\t\targs[\"looktarget\"] = vector3s[3];\n\t\t}\n\t\t\n\t\t//look applications:\n\t\tif(args.Contains(\"looktarget\")){\n\t\t\tiTween.LookUpdate(target,args);\n\t\t}\n\t\t\n\t\t//apply:\n\t\tif(isLocal){\n\t\t\ttarget.transform.localPosition = vector3s[3];\t\t\t\n\t\t}else{\n\t\t\ttarget.transform.position=vector3s[3];\t\n\t\t}\t\n\t\t\n\t\t//need physics?\n\t\tif(target.rigidbody != null){\n\t\t\tVector3 postUpdate=target.transform.position;\n\t\t\ttarget.transform.position=preUpdate;\n\t\t\ttarget.rigidbody.MovePosition(postUpdate);\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// Similar to MoveTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with MINIMUM customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"position\">\n\t/// A <see cref=\"Vector3\"/> for a point in space the GameObject will animate to.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void MoveUpdate(GameObject target, Vector3 position, float time){\n\t\tMoveUpdate(target,Hash(\"position\",position,\"time\",time));\n\t}\n\t\n\t/// <summary>\n\t/// Similar to LookTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with FULL customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Transform\"/> or <see cref=\"Vector3\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"axis\">\n\t/// A <see cref=\"System.String\"/>. Restricts rotation to the supplied axis only.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> or <see cref=\"System.Double\"/> for the time in seconds the animation will take to complete.\n\t/// </param> \n\tpublic static void LookUpdate(GameObject target, Hashtable args){\n\t\tCleanArgs(args);\n\t\t\n\t\tfloat time;\n\t\tVector3[] vector3s = new Vector3[5];\n\t\t\n\t\t//set smooth time:\n\t\tif(args.Contains(\"looktime\")){\n\t\t\ttime=(float)args[\"looktime\"];\n\t\t\ttime*=Defaults.updateTimePercentage;\n\t\t}else if(args.Contains(\"time\")){\n\t\t\ttime=(float)args[\"time\"]*.15f;\n\t\t\ttime*=Defaults.updateTimePercentage;\n\t\t}else{\n\t\t\ttime=Defaults.updateTime;\n\t\t}\n\t\t\n\t\t//from values:\n\t\tvector3s[0] = target.transform.eulerAngles;\n\t\t\n\t\t//set look:\n\t\tif(args.Contains(\"looktarget\")){\n\t\t\tif (args[\"looktarget\"].GetType() == typeof(Transform)) {\n\t\t\t\t//target.transform.LookAt((Transform)args[\"looktarget\"]);\n\t\t\t\ttarget.transform.LookAt((Transform)args[\"looktarget\"], (Vector3?)args[\"up\"] ?? Defaults.up);\n\t\t\t}else if(args[\"looktarget\"].GetType() == typeof(Vector3)){\n\t\t\t\t//target.transform.LookAt((Vector3)args[\"looktarget\"]);\n\t\t\t\ttarget.transform.LookAt((Vector3)args[\"looktarget\"], (Vector3?)args[\"up\"] ?? Defaults.up);\n\t\t\t}\n\t\t}else{\n\t\t\tDebug.LogError(\"iTween Error: LookUpdate needs a 'looktarget' property!\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//to values and reset look:\n\t\tvector3s[1]=target.transform.eulerAngles;\n\t\ttarget.transform.eulerAngles=vector3s[0];\n\t\t\n\t\t//calculate:\n\t\tvector3s[3].x=Mathf.SmoothDampAngle(vector3s[0].x,vector3s[1].x,ref vector3s[2].x,time);\n\t\tvector3s[3].y=Mathf.SmoothDampAngle(vector3s[0].y,vector3s[1].y,ref vector3s[2].y,time);\n\t\tvector3s[3].z=Mathf.SmoothDampAngle(vector3s[0].z,vector3s[1].z,ref vector3s[2].z,time);\n\t\n\t\t//apply:\n\t\ttarget.transform.eulerAngles=vector3s[3];\n\t\t\n\t\t//axis restriction:\n\t\tif(args.Contains(\"axis\")){\n\t\t\tvector3s[4]=target.transform.eulerAngles;\n\t\t\tswitch((string)args[\"axis\"]){\n\t\t\t\tcase \"x\":\n\t\t\t\t\tvector3s[4].y=vector3s[0].y;\n\t\t\t\t\tvector3s[4].z=vector3s[0].z;\n\t\t\t\tbreak;\n\t\t\t\tcase \"y\":\n\t\t\t\t\tvector3s[4].x=vector3s[0].x;\n\t\t\t\t\tvector3s[4].z=vector3s[0].z;\n\t\t\t\tbreak;\n\t\t\t\tcase \"z\":\n\t\t\t\t\tvector3s[4].x=vector3s[0].x;\n\t\t\t\t\tvector3s[4].y=vector3s[0].y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t//apply axis restriction:\n\t\t\ttarget.transform.eulerAngles=vector3s[4];\n\t\t}\t\n\t}\n\t\n\t/// <summary>\n\t/// Similar to LookTo but incredibly less expensive for usage inside the Update function or similar looping situations involving a \"live\" set of changing values with FULL customization options. Does not utilize an EaseType. \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/> to be the target of the animation.\n\t/// </param>\n\t/// <param name=\"looktarget\">\n\t/// A <see cref=\"Vector3\"/> for a target the GameObject will look at.\n\t/// </param>\n\t/// <param name=\"time\">\n\t/// A <see cref=\"System.Single\"/> for the time in seconds the animation will take to complete.\n\t/// </param>\n\tpublic static void LookUpdate(GameObject target, Vector3 looktarget, float time){\n\t\tLookUpdate(target,Hash(\"looktarget\",looktarget,\"time\",time));\n\t}\n\n\t#endregion\n\t\n\t#region #7 External Utilities\n\t\n\t/// <summary>\n\t/// Returns the length of a curved path drawn through the provided array of Transforms.\n\t/// </summary>\n\t/// <returns>\n\t/// A <see cref=\"System.Single\"/>\n\t/// </returns>\n\t/// <param name='path'>\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\tpublic static float PathLength(Transform[] path){\n\t\tVector3[] suppliedPath = new Vector3[path.Length];\n\t\tfloat pathLength = 0;\n\t\t\n\t\t//create and store path points:\n\t\tfor (int i = 0; i < path.Length; i++) {\n\t\t\tsuppliedPath[i]=path[i].position;\n\t\t}\n\t\t\n\t\tVector3[] vector3s = PathControlPointGenerator(suppliedPath);\n\t\t\n\t\t//Line Draw:\n\t\tVector3 prevPt = Interp(vector3s,0);\n\t\tint SmoothAmount = path.Length*20;\n\t\tfor (int i = 1; i <= SmoothAmount; i++) {\n\t\t\tfloat pm = (float) i / SmoothAmount;\n\t\t\tVector3 currPt = Interp(vector3s,pm);\n\t\t\tpathLength += Vector3.Distance(prevPt,currPt);\n\t\t\tprevPt = currPt;\n\t\t}\n\t\t\n\t\treturn pathLength;\n\t}\n\t\n\t/// <summary>\n\t/// Returns the length of a curved path drawn through the provided array of Vector3s.\n\t/// </summary>\n\t/// <returns>\n\t/// The length.\n\t/// </returns>\n\t/// <param name='path'>\n\t/// A <see cref=\"Vector3[]\"/>\n\t/// </param>\n\tpublic static float PathLength(Vector3[] path){\n\t\tfloat pathLength = 0;\n\t\t\n\t\tVector3[] vector3s = PathControlPointGenerator(path);\n\t\t\n\t\t//Line Draw:\n\t\tVector3 prevPt = Interp(vector3s,0);\n\t\tint SmoothAmount = path.Length*20;\n\t\tfor (int i = 1; i <= SmoothAmount; i++) {\n\t\t\tfloat pm = (float) i / SmoothAmount;\n\t\t\tVector3 currPt = Interp(vector3s,pm);\n\t\t\tpathLength += Vector3.Distance(prevPt,currPt);\n\t\t\tprevPt = currPt;\n\t\t}\n\t\t\n\t\treturn pathLength;\n\t}\t\n\t\n\t/// <summary>\n\t/// Creates and returns a full-screen Texture2D for use with CameraFade.\n\t/// </summary>\n\t/// <returns>\n\t/// Texture2D\n\t/// </returns>\n\t/// <param name='color'>\n\t/// Color\n\t/// </param>\n\tpublic static Texture2D CameraTexture(Color color){\n\t\tTexture2D texture = new Texture2D(Screen.width,Screen.height,TextureFormat.ARGB32, false);\n\t\tColor[] colors = new Color[Screen.width*Screen.height];\n\t\tfor (int i = 0; i < colors.Length; i++) {\n\t\t\tcolors[i]=color;\n\t\t}\n\t\ttexture.SetPixels(colors);\n\t\ttexture.Apply();\n\t\treturn(texture);\t\t\n\t}\n\t\n\t/// <summary>\n\t/// Puts a GameObject on a path at the provided percentage \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/>\n\t/// </param>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Vector3[]\"/>\n\t/// </param>\n\t/// <param name=\"percent\">\n\t/// A <see cref=\"System.Single\"/>\n\t/// </param>\n\tpublic static void PutOnPath(GameObject target, Vector3[] path, float percent){\n\t\ttarget.transform.position=Interp(PathControlPointGenerator(path),percent);\n\t}\n\t\n\t/// <summary>\n\t/// Puts a GameObject on a path at the provided percentage \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"Transform\"/>\n\t/// </param>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Vector3[]\"/>\n\t/// </param>\n\t/// <param name=\"percent\">\n\t/// A <see cref=\"System.Single\"/>\n\t/// </param>\n\tpublic static void PutOnPath(Transform target, Vector3[] path, float percent){\n\t\ttarget.position=Interp(PathControlPointGenerator(path),percent);\n\t}\t\n\t\n\t/// <summary>\n\t/// Puts a GameObject on a path at the provided percentage \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"GameObject\"/>\n\t/// </param>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\t/// <param name=\"percent\">\n\t/// A <see cref=\"System.Single\"/>\n\t/// </param>\n\tpublic static void PutOnPath(GameObject target, Transform[] path, float percent){\n\t\t//create and store path points:\n\t\tVector3[] suppliedPath = new Vector3[path.Length];\n\t\tfor (int i = 0; i < path.Length; i++) {\n\t\t\tsuppliedPath[i]=path[i].position;\n\t\t}\t\n\t\ttarget.transform.position=Interp(PathControlPointGenerator(suppliedPath),percent);\n\t}\t\n\t\n\t/// <summary>\n\t/// Puts a GameObject on a path at the provided percentage \n\t/// </summary>\n\t/// <param name=\"target\">\n\t/// A <see cref=\"Transform\"/>\n\t/// </param>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\t/// <param name=\"percent\">\n\t/// A <see cref=\"System.Single\"/>\n\t/// </param>\n\tpublic static void PutOnPath(Transform target, Transform[] path, float percent){\n\t\t//create and store path points:\n\t\tVector3[] suppliedPath = new Vector3[path.Length];\n\t\tfor (int i = 0; i < path.Length; i++) {\n\t\t\tsuppliedPath[i]=path[i].position;\n\t\t}\t\n\t\ttarget.position=Interp(PathControlPointGenerator(suppliedPath),percent);\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Returns a Vector3 position on a path at the provided percentage  \n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\t/// <param name=\"percent\">\n\t/// A <see cref=\"System.Single\"/>\n\t/// </param>\n\t/// <returns>\n\t/// A <see cref=\"Vector3\"/>\n\t/// </returns>\n\tpublic static Vector3 PointOnPath(Transform[] path, float percent){\n\t\t//create and store path points:\n\t\tVector3[] suppliedPath = new Vector3[path.Length];\n\t\tfor (int i = 0; i < path.Length; i++) {\n\t\t\tsuppliedPath[i]=path[i].position;\n\t\t}\t\n\t\treturn(Interp(PathControlPointGenerator(suppliedPath),percent));\n\t}\n\t\t\n\t/// <summary>\n\t/// When called from an OnDrawGizmos() function it will draw a line through the provided array of Vector3s.\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\tpublic static void DrawLine(Vector3[] line) {\n\t\tif(line.Length>0){\n\t\t\tDrawLineHelper(line,Defaults.color,\"gizmos\");\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// When called from an OnDrawGizmos() function it will draw a line through the provided array of Vector3s.\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawLine(Vector3[] line, Color color) {\n\t\tif(line.Length>0){\n\t\t\tDrawLineHelper(line,color,\"gizmos\");\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// When called from an OnDrawGizmos() function it will draw a line through the provided array of Transforms.\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\tpublic static void DrawLine(Transform[] line) {\n\t\tif(line.Length>0){\n\t\t\t//create and store line points:\n\t\t\tVector3[] suppliedLine = new Vector3[line.Length];\n\t\t\tfor (int i = 0; i < line.Length; i++) {\n\t\t\t\tsuppliedLine[i]=line[i].position;\n\t\t\t}\n\t\t\tDrawLineHelper(suppliedLine,Defaults.color,\"gizmos\");\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// When called from an OnDrawGizmos() function it will draw a line through the provided array of Transforms.\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawLine(Transform[] line,Color color) {\n\t\tif(line.Length>0){\n\t\t\t//create and store line points:\n\t\t\tVector3[] suppliedLine = new Vector3[line.Length];\n\t\t\tfor (int i = 0; i < line.Length; i++) {\n\t\t\t\tsuppliedLine[i]=line[i].position;\n\t\t\t}\n\t\t\t\n\t\t\tDrawLineHelper(suppliedLine, color,\"gizmos\");\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Draws a line through the provided array of Vector3s with Gizmos.DrawLine().\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\tpublic static void DrawLineGizmos(Vector3[] line) {\n\t\tif(line.Length>0){\n\t\t\tDrawLineHelper(line,Defaults.color,\"gizmos\");\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Draws a line through the provided array of Vector3s with Gizmos.DrawLine().\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawLineGizmos(Vector3[] line, Color color) {\n\t\tif(line.Length>0){\n\t\t\tDrawLineHelper(line,color,\"gizmos\");\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Draws a line through the provided array of Transforms with Gizmos.DrawLine().\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\tpublic static void DrawLineGizmos(Transform[] line) {\n\t\tif(line.Length>0){\n\t\t\t//create and store line points:\n\t\t\tVector3[] suppliedLine = new Vector3[line.Length];\n\t\t\tfor (int i = 0; i < line.Length; i++) {\n\t\t\t\tsuppliedLine[i]=line[i].position;\n\t\t\t}\n\t\t\tDrawLineHelper(suppliedLine,Defaults.color,\"gizmos\");\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Draws a line through the provided array of Transforms with Gizmos.DrawLine().\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawLineGizmos(Transform[] line,Color color) {\n\t\tif(line.Length>0){\n\t\t\t//create and store line points:\n\t\t\tVector3[] suppliedLine = new Vector3[line.Length];\n\t\t\tfor (int i = 0; i < line.Length; i++) {\n\t\t\t\tsuppliedLine[i]=line[i].position;\n\t\t\t}\n\t\t\t\n\t\t\tDrawLineHelper(suppliedLine, color,\"gizmos\");\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// Draws a line through the provided array of Vector3s with Handles.DrawLine().\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\tpublic static void DrawLineHandles(Vector3[] line) {\n\t\tif(line.Length>0){\n\t\t\tDrawLineHelper(line,Defaults.color,\"handles\");\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Draws a line through the provided array of Vector3s with Handles.DrawLine().\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawLineHandles(Vector3[] line, Color color) {\n\t\tif(line.Length>0){\n\t\t\tDrawLineHelper(line,color,\"handles\");\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Draws a line through the provided array of Transforms with Handles.DrawLine().\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\tpublic static void DrawLineHandles(Transform[] line) {\n\t\tif(line.Length>0){\n\t\t\t//create and store line points:\n\t\t\tVector3[] suppliedLine = new Vector3[line.Length];\n\t\t\tfor (int i = 0; i < line.Length; i++) {\n\t\t\t\tsuppliedLine[i]=line[i].position;\n\t\t\t}\n\t\t\tDrawLineHelper(suppliedLine,Defaults.color,\"handles\");\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Draws a line through the provided array of Transforms with Handles.DrawLine().\n\t/// </summary>\n\t/// <param name=\"line\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawLineHandles(Transform[] line,Color color) {\n\t\tif(line.Length>0){\n\t\t\t//create and store line points:\n\t\t\tVector3[] suppliedLine = new Vector3[line.Length];\n\t\t\tfor (int i = 0; i < line.Length; i++) {\n\t\t\t\tsuppliedLine[i]=line[i].position;\n\t\t\t}\n\t\t\t\n\t\t\tDrawLineHelper(suppliedLine, color,\"handles\");\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Returns a Vector3 position on a path at the provided percentage  \n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Vector3[]\"/>\n\t/// </param>\n\t/// <param name=\"percent\">\n\t/// A <see cref=\"System.Single\"/>\n\t/// </param>\n\t/// <returns>\n\t/// A <see cref=\"Vector3\"/>\n\t/// </returns>\n\tpublic static Vector3 PointOnPath(Vector3[] path, float percent){\n\t\treturn(Interp(PathControlPointGenerator(path),percent));\n\t}\t\t\n\t\n\t/// <summary>\n\t/// When called from an OnDrawGizmos() function it will draw a curved path through the provided array of Vector3s.\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\tpublic static void DrawPath(Vector3[] path) {\n\t\tif(path.Length>0){\n\t\t\tDrawPathHelper(path,Defaults.color,\"gizmos\");\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// When called from an OnDrawGizmos() function it will draw a curved path through the provided array of Vector3s.\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawPath(Vector3[] path, Color color) {\n\t\tif(path.Length>0){\n\t\t\tDrawPathHelper(path, color,\"gizmos\");\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// When called from an OnDrawGizmos() function it will draw a curved path through the provided array of Transforms.\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\tpublic static void DrawPath(Transform[] path) {\n\t\tif(path.Length>0){\n\t\t\t//create and store path points:\n\t\t\tVector3[] suppliedPath = new Vector3[path.Length];\n\t\t\tfor (int i = 0; i < path.Length; i++) {\n\t\t\t\tsuppliedPath[i]=path[i].position;\n\t\t\t}\n\t\t\t\n\t\t\tDrawPathHelper(suppliedPath,Defaults.color,\"gizmos\");\t\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// When called from an OnDrawGizmos() function it will draw a curved path through the provided array of Transforms.\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawPath(Transform[] path,Color color) {\n\t\tif(path.Length>0){\n\t\t\t//create and store path points:\n\t\t\tVector3[] suppliedPath = new Vector3[path.Length];\n\t\t\tfor (int i = 0; i < path.Length; i++) {\n\t\t\t\tsuppliedPath[i]=path[i].position;\n\t\t\t}\n\t\t\t\n\t\t\tDrawPathHelper(suppliedPath, color,\"gizmos\");\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Draws a curved path through the provided array of Vector3s with Gizmos.DrawLine().\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\tpublic static void DrawPathGizmos(Vector3[] path) {\n\t\tif(path.Length>0){\n\t\t\tDrawPathHelper(path,Defaults.color,\"gizmos\");\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Draws a curved path through the provided array of Vector3s with Gizmos.DrawLine().\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawPathGizmos(Vector3[] path, Color color) {\n\t\tif(path.Length>0){\n\t\t\tDrawPathHelper(path, color,\"gizmos\");\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Draws a curved path through the provided array of Transforms with Gizmos.DrawLine().\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\tpublic static void DrawPathGizmos(Transform[] path) {\n\t\tif(path.Length>0){\n\t\t\t//create and store path points:\n\t\t\tVector3[] suppliedPath = new Vector3[path.Length];\n\t\t\tfor (int i = 0; i < path.Length; i++) {\n\t\t\t\tsuppliedPath[i]=path[i].position;\n\t\t\t}\n\t\t\t\n\t\t\tDrawPathHelper(suppliedPath,Defaults.color,\"gizmos\");\t\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Draws a curved path through the provided array of Transforms with Gizmos.DrawLine().\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawPathGizmos(Transform[] path,Color color) {\n\t\tif(path.Length>0){\n\t\t\t//create and store path points:\n\t\t\tVector3[] suppliedPath = new Vector3[path.Length];\n\t\t\tfor (int i = 0; i < path.Length; i++) {\n\t\t\t\tsuppliedPath[i]=path[i].position;\n\t\t\t}\n\t\t\t\n\t\t\tDrawPathHelper(suppliedPath, color,\"gizmos\");\n\t\t}\n\t}\t\n\n\t/// <summary>\n\t/// Draws a curved path through the provided array of Vector3s with Handles.DrawLine().\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\tpublic static void DrawPathHandles(Vector3[] path) {\n\t\tif(path.Length>0){\n\t\t\tDrawPathHelper(path,Defaults.color,\"handles\");\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Draws a curved path through the provided array of Vector3s with Handles.DrawLine().\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Vector3s[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawPathHandles(Vector3[] path, Color color) {\n\t\tif(path.Length>0){\n\t\t\tDrawPathHelper(path, color,\"handles\");\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Draws a curved path through the provided array of Transforms with Handles.DrawLine().\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\tpublic static void DrawPathHandles(Transform[] path) {\n\t\tif(path.Length>0){\n\t\t\t//create and store path points:\n\t\t\tVector3[] suppliedPath = new Vector3[path.Length];\n\t\t\tfor (int i = 0; i < path.Length; i++) {\n\t\t\t\tsuppliedPath[i]=path[i].position;\n\t\t\t}\n\t\t\t\n\t\t\tDrawPathHelper(suppliedPath,Defaults.color,\"handles\");\t\n\t\t}\n\t}\t\t\n\t\n\t/// <summary>\n\t/// Draws a curved path through the provided array of Transforms with Handles.DrawLine().\n\t/// </summary>\n\t/// <param name=\"path\">\n\t/// A <see cref=\"Transform[]\"/>\n\t/// </param>\n\t/// <param name=\"color\">\n\t/// A <see cref=\"Color\"/>\n\t/// </param> \n\tpublic static void DrawPathHandles(Transform[] path,Color color) {\n\t\tif(path.Length>0){\n\t\t\t//create and store path points:\n\t\t\tVector3[] suppliedPath = new Vector3[path.Length];\n\t\t\tfor (int i = 0; i < path.Length; i++) {\n\t\t\t\tsuppliedPath[i]=path[i].position;\n\t\t\t}\n\t\t\t\n\t\t\tDrawPathHelper(suppliedPath, color,\"handles\");\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Changes a camera fade's texture.\n\t/// </summary>\n\t/// <param name=\"depth\">\n\t/// A <see cref=\"System.Int32\"/>\n\t/// </param>\n\tpublic static void CameraFadeDepth(int depth){\n\t\tif(cameraFade){\n\t\t\tcameraFade.transform.position=new Vector3(cameraFade.transform.position.x,cameraFade.transform.position.y,depth);\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Removes and destroyes a camera fade.\n\t/// </summary>\n\tpublic static void CameraFadeDestroy(){\n\t\tif(cameraFade){\n\t\t\tDestroy(cameraFade);\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Changes a camera fade's texture.\n\t/// </summary>\n\t/// <param name='texture'>\n\t/// A <see cref=\"Texture2D\"/>\n\t/// </param>\n\tpublic static void CameraFadeSwap(Texture2D texture){\n\t\tif(cameraFade){\n\t\t\tcameraFade.guiTexture.texture=texture;\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Creates a GameObject (if it doesn't exist) at the supplied depth that can be used to simulate a camera fade.\n\t/// </summary>\n\t/// <param name='texture'>\n\t/// A <see cref=\"Texture2D\"/>\n\t/// </param>\n\t/// <param name='depth'>\n\t/// A <see cref=\"System.Int32\"/>\n\t/// </param>\n\t/// <returns>\n\t/// A <see cref=\"GameObject\"/> for a reference to the CameraFade.\n\t/// </returns>\n\tpublic static GameObject CameraFadeAdd(Texture2D texture, int depth){\n\t\tif(cameraFade){\n\t\t\treturn null;\n\t\t}else{\t\t\t\n\t\t\t//establish colorFade object:\n\t\t\tcameraFade = new GameObject(\"iTween Camera Fade\");\n\t\t\tcameraFade.transform.position= new Vector3(.5f,.5f,depth);\n\t\t\tcameraFade.AddComponent(\"GUITexture\");\n\t\t\tcameraFade.guiTexture.texture=texture;\n\t\t\tcameraFade.guiTexture.color = new Color(.5f,.5f,.5f,0);\n\t\t\treturn cameraFade;\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Creates a GameObject (if it doesn't exist) at the default depth that can be used to simulate a camera fade.\n\t/// </summary>\n\t/// <param name='texture'>\n\t/// A <see cref=\"Texture2D\"/>\n\t/// </param>\n\t/// <returns>\n\t/// A <see cref=\"GameObject\"/> for a reference to the CameraFade.\n\t/// </returns>\n\tpublic static GameObject CameraFadeAdd(Texture2D texture){\n\t\tif(cameraFade){\n\t\t\treturn null;\n\t\t}else{\t\t\t\n\t\t\t//establish colorFade object:\n\t\t\tcameraFade = new GameObject(\"iTween Camera Fade\");\n\t\t\tcameraFade.transform.position= new Vector3(.5f,.5f,Defaults.cameraFadeDepth);\n\t\t\tcameraFade.AddComponent(\"GUITexture\");\n\t\t\tcameraFade.guiTexture.texture=texture;\n\t\t\tcameraFade.guiTexture.color = new Color(.5f,.5f,.5f,0);\n\t\t\treturn cameraFade;\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Creates a GameObject (if it doesn't exist) at the default depth filled with black that can be used to simulate a camera fade.\n\t/// </summary>\n\t/// <returns>\n\t/// A <see cref=\"GameObject\"/> for a reference to the CameraFade.\n\t/// </returns>\n\tpublic static GameObject CameraFadeAdd(){\n\t\tif(cameraFade){\n\t\t\treturn null;\n\t\t}else{\t\t\t\n\t\t\t//establish colorFade object:\n\t\t\tcameraFade = new GameObject(\"iTween Camera Fade\");\n\t\t\tcameraFade.transform.position= new Vector3(.5f,.5f,Defaults.cameraFadeDepth);\n\t\t\tcameraFade.AddComponent(\"GUITexture\");\n\t\t\tcameraFade.guiTexture.texture=CameraTexture(Color.black);\n\t\t\tcameraFade.guiTexture.color = new Color(.5f,.5f,.5f,0);\n\t\t\treturn cameraFade;\n\t\t}\n\t}\t\n\t\n\t\n\t//#################################\n\t//# RESUME UTILITIES AND OVERLOADS # \n\t//#################################\t\n\t\n\t/// <summary>\n\t/// Resume all iTweens on a GameObject.\n\t/// </summary>\n\tpublic static void Resume(GameObject target){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\titem.enabled=true;\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Resume all iTweens on a GameObject including its children.\n\t/// </summary>\n\tpublic static void Resume(GameObject target, bool includechildren){\n\t\tResume(target);\n\t\tif(includechildren){\n\t\t\tforeach(Transform child in target.transform){\n\t\t\t\tResume(child.gameObject,true);\n\t\t\t}\t\t\t\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Resume all iTweens on a GameObject of a particular type.\n\t/// </summar\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to resume.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param>\t\n\tpublic static void Resume(GameObject target, string type){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\tstring targetType = item.type+item.method;\n\t\t\ttargetType=targetType.Substring(0,type.Length);\n\t\t\tif(targetType.ToLower() == type.ToLower()){\n\t\t\t\titem.enabled=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Resume all iTweens on a GameObject of a particular type including its children.\n\t/// </summar\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to resume.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param>\t\n\tpublic static void Resume(GameObject target, string type, bool includechildren){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\tstring targetType = item.type+item.method;\n\t\t\ttargetType=targetType.Substring(0,type.Length);\n\t\t\tif(targetType.ToLower() == type.ToLower()){\n\t\t\t\titem.enabled=true;\n\t\t\t}\n\t\t}\n\t\tif(includechildren){\n\t\t\tforeach(Transform child in target.transform){\n\t\t\t\tResume(child.gameObject,type,true);\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t}\t\n\t\n\t/// <summary>\n\t/// Resume all iTweens in scene.\n\t/// </summary>\n\tpublic static void Resume(){\n\t\tfor (int i = 0; i < tweens.Count; i++) {\n\t\t\tHashtable currentTween = (Hashtable)tweens[i];\n\t\t\tGameObject target = (GameObject)currentTween[\"target\"];\n\t\t\tResume(target);\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Resume all iTweens in scene of a particular type.\n\t/// </summary>\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to resume.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param> \n\tpublic static void Resume(string type){\n\t\tArrayList resumeArray = new ArrayList();\n\t\t\n\t\tfor (int i = 0; i < tweens.Count; i++) {\n\t\t\tHashtable currentTween = (Hashtable)tweens[i];\n\t\t\tGameObject target = (GameObject)currentTween[\"target\"];\n\t\t\tresumeArray.Insert(resumeArray.Count,target);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < resumeArray.Count; i++) {\n\t\t\tResume((GameObject)resumeArray[i],type);\n\t\t}\n\t}\t\t\t\n\t\n\t//#################################\n\t//# PAUSE UTILITIES AND OVERLOADS # \n\t//#################################\n\n\t/// <summary>\n\t/// Pause all iTweens on a GameObject.\n\t/// </summary>\n\tpublic static void Pause(GameObject target){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\tif(item.delay>0){\n\t\t\t\titem.delay-=Time.time-item.delayStarted;\n\t\t\t\titem.StopCoroutine(\"TweenDelay\");\n\t\t\t}\n\t\t\titem.isPaused=true;\n\t\t\titem.enabled=false;\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Pause all iTweens on a GameObject including its children.\n\t/// </summary>\n\tpublic static void Pause(GameObject target, bool includechildren){\n\t\tPause(target);\n\t\tif(includechildren){\n\t\t\tforeach(Transform child in target.transform){\n\t\t\t\tPause(child.gameObject,true);\n\t\t\t}\t\t\t\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Pause all iTweens on a GameObject of a particular type.\n\t/// </summar\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to pause.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param>\t\n\tpublic static void Pause(GameObject target, string type){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\tstring targetType = item.type+item.method;\n\t\t\ttargetType=targetType.Substring(0,type.Length);\n\t\t\tif(targetType.ToLower() == type.ToLower()){\n\t\t\t\tif(item.delay>0){\n\t\t\t\t\titem.delay-=Time.time-item.delayStarted;\n\t\t\t\t\titem.StopCoroutine(\"TweenDelay\");\n\t\t\t\t}\n\t\t\t\titem.isPaused=true;\n\t\t\t\titem.enabled=false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Pause all iTweens on a GameObject of a particular type including its children.\n\t/// </summar\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to pause.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param>\t\n\tpublic static void Pause(GameObject target, string type, bool includechildren){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\tstring targetType = item.type+item.method;\n\t\t\ttargetType=targetType.Substring(0,type.Length);\n\t\t\tif(targetType.ToLower() == type.ToLower()){\n\t\t\t\tif(item.delay>0){\n\t\t\t\t\titem.delay-=Time.time-item.delayStarted;\n\t\t\t\t\titem.StopCoroutine(\"TweenDelay\");\n\t\t\t\t}\n\t\t\t\titem.isPaused=true;\n\t\t\t\titem.enabled=false;\n\t\t\t}\n\t\t}\n\t\tif(includechildren){\n\t\t\tforeach(Transform child in target.transform){\n\t\t\t\tPause(child.gameObject,type,true);\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t}\t\n\t\n\t/// <summary>\n\t/// Pause all iTweens in scene.\n\t/// </summary>\n\tpublic static void Pause(){\n\t\tfor (int i = 0; i < tweens.Count; i++) {\n\t\t\tHashtable currentTween = (Hashtable)tweens[i];\n\t\t\tGameObject target = (GameObject)currentTween[\"target\"];\n\t\t\tPause(target);\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Pause all iTweens in scene of a particular type.\n\t/// </summary>\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to pause.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param> \n\tpublic static void Pause(string type){\n\t\tArrayList pauseArray = new ArrayList();\n\t\t\n\t\tfor (int i = 0; i < tweens.Count; i++) {\n\t\t\tHashtable currentTween = (Hashtable)tweens[i];\n\t\t\tGameObject target = (GameObject)currentTween[\"target\"];\n\t\t\tpauseArray.Insert(pauseArray.Count,target);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < pauseArray.Count; i++) {\n\t\t\tPause((GameObject)pauseArray[i],type);\n\t\t}\n\t}\t\t\n\t\n\t//#################################\n\t//# COUNT UTILITIES AND OVERLOADS # \n\t//#################################\t\n\t\n\t/// <summary>\n\t/// Count all iTweens in current scene.\n\t/// </summary>\n\tpublic static int Count(){\n\t\treturn(tweens.Count);\n\t}\n\t\n\t/// <summary>\n\t/// Count all iTweens in current scene of a particular type.\n\t/// </summary>\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to stop.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param> \n\tpublic static int Count(string type){\n\t\tint tweenCount = 0;\n\n\t\tfor (int i = 0; i < tweens.Count; i++) {\n\t\t\tHashtable currentTween = (Hashtable)tweens[i];\n\t\t\tstring targetType = (string)currentTween[\"type\"]+(string)currentTween[\"method\"];\n\t\t\ttargetType=targetType.Substring(0,type.Length);\n\t\t\tif(targetType.ToLower() == type.ToLower()){\n\t\t\t\ttweenCount++;\n\t\t\t}\n\t\t}\t\n\t\t\n\t\treturn(tweenCount);\n\t}\t\t\t\n\n\t/// <summary>\n\t/// Count all iTweens on a GameObject.\n\t/// </summary>\n\tpublic static int Count(GameObject target){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\treturn(tweens.Length);\n\t}\n\t\n\t/// <summary>\n\t/// Count all iTweens on a GameObject of a particular type.\n\t/// </summary>\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to count.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param>  \n\tpublic static int Count(GameObject target, string type){\n\t\tint tweenCount = 0;\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));foreach (iTween item in tweens){\n\t\t\tstring targetType = item.type+item.method;\n\t\t\ttargetType=targetType.Substring(0,type.Length);\n\t\t\tif(targetType.ToLower() == type.ToLower()){\n\t\t\t\ttweenCount++;\n\t\t\t}\n\t\t}\n\t\treturn(tweenCount);\n\t}\t\n\t\n\t//################################\n\t//# STOP UTILITIES AND OVERLOADS # \n\t//################################\t\n\t\n\t/// <summary>\n\t/// Stop and destroy all Tweens in current scene.\n\t/// </summary>\n\tpublic static void Stop(){\n\t\tfor (int i = 0; i < tweens.Count; i++) {\n\t\t\tHashtable currentTween = (Hashtable)tweens[i];\n\t\t\tGameObject target = (GameObject)currentTween[\"target\"];\n\t\t\tStop(target);\n\t\t}\n\t\ttweens.Clear();\n\t}\t\n\t\n\t/// <summary>\n\t/// Stop and destroy all iTweens in current scene of a particular type.\n\t/// </summary>\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to stop.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param> \n\tpublic static void Stop(string type){\n\t\tArrayList stopArray = new ArrayList();\n\t\t\n\t\tfor (int i = 0; i < tweens.Count; i++) {\n\t\t\tHashtable currentTween = (Hashtable)tweens[i];\n\t\t\tGameObject target = (GameObject)currentTween[\"target\"];\n\t\t\tstopArray.Insert(stopArray.Count,target);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < stopArray.Count; i++) {\n\t\t\tStop((GameObject)stopArray[i],type);\n\t\t}\n\t}\t\t\n\t\n\t/* GFX47 MOD START */\n\t/// <summary>\n\t/// Stop and destroy all iTweens in current scene of a particular name.\n\t/// </summary>\n\t/// <param name=\"name\">\n\t/// The <see cref=\"System.String\"/> name of iTween you would like to stop.\n\t/// </param> \n\tpublic static void StopByName(string name){\n\t\tArrayList stopArray = new ArrayList();\n\t\t\n\t\tfor (int i = 0; i < tweens.Count; i++) {\n\t\t\tHashtable currentTween = (Hashtable)tweens[i];\n\t\t\tGameObject target = (GameObject)currentTween[\"target\"];\n\t\t\tstopArray.Insert(stopArray.Count,target);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < stopArray.Count; i++) {\n\t\t\tStopByName((GameObject)stopArray[i],name);\n\t\t}\n\t}\n\t/* GFX47 MOD END */\n\t\n\t/// <summary>\n\t/// Stop and destroy all iTweens on a GameObject.\n\t/// </summary>\n\tpublic static void Stop(GameObject target){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\titem.Dispose();\n\t\t}\n\t}\n\t\n\t/// <summary>\n\t/// Stop and destroy all iTweens on a GameObject including its children.\n\t/// </summary>\n\tpublic static void Stop(GameObject target, bool includechildren){\n\t\tStop(target);\n\t\tif(includechildren){\n\t\t\tforeach(Transform child in target.transform){\n\t\t\t\tStop(child.gameObject,true);\n\t\t\t}\t\t\t\n\t\t}\n\t}\t\n\t\n\t/// <summary>\n\t/// Stop and destroy all iTweens on a GameObject of a particular type.\n\t/// </summar\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to stop.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param>\t\n\tpublic static void Stop(GameObject target, string type){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\tstring targetType = item.type+item.method;\n\t\t\ttargetType=targetType.Substring(0,type.Length);\n\t\t\tif(targetType.ToLower() == type.ToLower()){\n\t\t\t\titem.Dispose();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/* GFX47 MOD START */\n\t/// <summary>\n\t/// Stop and destroy all iTweens on a GameObject of a particular name.\n\t/// </summar\n\t/// <param name=\"name\">\n\t/// The <see cref=\"System.String\"/> name of iTween you would like to stop.\n\t/// </param>\t\n\tpublic static void StopByName(GameObject target, string name){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\t/*string targetType = item.type+item.method;\n\t\t\ttargetType=targetType.Substring(0,type.Length);\n\t\t\tif(targetType.ToLower() == type.ToLower()){\n\t\t\t\titem.Dispose();\n\t\t\t}*/\n\t\t\tif(item._name == name){\n\t\t\t\titem.Dispose();\n\t\t\t}\n\t\t}\n\t}\n\t/* GFX47 MOD END */\n\t\n\t/// <summary>\n\t/// Stop and destroy all iTweens on a GameObject of a particular type including its children.\n\t/// </summar\n\t/// <param name=\"type\">\n\t/// A <see cref=\"System.String\"/> name of the type of iTween you would like to stop.  Can be written as part of a name such as \"mov\" for all \"MoveTo\" iTweens.\n\t/// </param>\t\n\tpublic static void Stop(GameObject target, string type, bool includechildren){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\tstring targetType = item.type+item.method;\n\t\t\ttargetType=targetType.Substring(0,type.Length);\n\t\t\tif(targetType.ToLower() == type.ToLower()){\n\t\t\t\titem.Dispose();\n\t\t\t}\n\t\t}\n\t\tif(includechildren){\n\t\t\tforeach(Transform child in target.transform){\n\t\t\t\tStop(child.gameObject,type,true);\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t}\n\t\n\t/* GFX47 MOD START */\n\t/// <summary>\n\t/// Stop and destroy all iTweens on a GameObject of a particular name including its children.\n\t/// </summar\n\t/// <param name=\"name\">\n\t/// The <see cref=\"System.String\"/> name of iTween you would like to stop.\n\t/// </param>\t\n\tpublic static void StopByName(GameObject target, string name, bool includechildren){\n\t\tComponent[] tweens = target.GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens){\n\t\t\t/*string targetType = item.type+item.method;\n\t\t\ttargetType=targetType.Substring(0,type.Length);\n\t\t\tif(targetType.ToLower() == type.ToLower()){\n\t\t\t\titem.Dispose();\n\t\t\t}*/\n\t\t\tif(item._name == name){\n\t\t\t\titem.Dispose();\n\t\t\t}\n\t\t}\n\t\tif(includechildren){\n\t\t\tforeach(Transform child in target.transform){\n\t\t\t\t//Stop(child.gameObject,type,true);\n\t\t\t\tStopByName(child.gameObject,name,true);\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t}\n\t/* GFX47 MOD END */\n\n\t/// <summary>\n\t/// Universal interface to help in the creation of Hashtables.  Especially useful for C# users.\n\t/// </summary>\n\t/// <param name=\"args\">\n\t/// A <see cref=\"System.Object[]\"/> of alternating name value pairs.  For example \"time\",1,\"delay\",2...\n\t/// </param>\n\t/// <returns>\n\t/// A <see cref=\"Hashtable\"/>\n\t/// </returns>\n\tpublic static Hashtable Hash(params object[] args){\n\t\tHashtable hashTable = new Hashtable(args.Length/2);\n\t\tif (args.Length %2 != 0) {\n\t\t\tDebug.LogError(\"Tween Error: Hash requires an even number of arguments!\"); \n\t\t\treturn null;\n\t\t}else{\n\t\t\tint i = 0;\n\t\t\twhile(i < args.Length - 1) {\n\t\t\t\thashTable.Add(args[i], args[i+1]);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t\treturn hashTable;\n\t\t}\n\t}\t\n\t\n\t#endregion\t\t\n\n\t#region Component Segments\n\t\n\tvoid Awake(){\n\t\tRetrieveArgs();\n        lastRealTime = Time.realtimeSinceStartup; // Added by PressPlay\n\t}\n\t\n\tIEnumerator Start(){\n\t\tif(delay > 0){\n\t\t\tyield return StartCoroutine(\"TweenDelay\");\n\t\t}\n\t\tTweenStart();\n\t}\t\n\t\n\t//non-physics\n\tvoid Update(){\n\t\tif(isRunning && !physics){\n\t\t\tif(!reverse){\n\t\t\t\tif(percentage<1f){\n\t\t\t\t\tTweenUpdate();\n\t\t\t\t}else{\n\t\t\t\t\tTweenComplete();\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(percentage>0){\n\t\t\t\t\tTweenUpdate();\n\t\t\t\t}else{\n\t\t\t\t\tTweenComplete();\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//physics\n\tvoid FixedUpdate(){\n\t\tif(isRunning && physics){\n\t\t\tif(!reverse){\n\t\t\t\tif(percentage<1f){\n\t\t\t\t\tTweenUpdate();\n\t\t\t\t}else{\n\t\t\t\t\tTweenComplete();\t\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(percentage>0){\n\t\t\t\t\tTweenUpdate();\n\t\t\t\t}else{\n\t\t\t\t\tTweenComplete();\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\n\tvoid LateUpdate(){\n\t\t//look applications:\n\t\tif(tweenArguments.Contains(\"looktarget\") && isRunning){\n\t\t\tif(type ==\"move\" || type ==\"shake\" || type==\"punch\"){\n\t\t\t\tLookUpdate(gameObject,tweenArguments);\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\t\n\tvoid OnEnable(){\n\t\tif(isRunning){\n\t\t\tEnableKinematic();\n\t\t}\n\t\n\t\t//resume delay:\n\t\tif(isPaused){\n\t\t\tisPaused=false;\n\t\t\tif(delay > 0){\n\t\t\t\twasPaused=true;\n\t\t\t\tResumeDelay();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid OnDisable(){\n\t\tDisableKinematic();\n\t}\n\t\n\t#endregion\n\t\n\t#region Internal Helpers\n\t\n\tprivate static void DrawLineHelper(Vector3[] line, Color color, string method){\n\t\tGizmos.color=color;\n\t\tfor (int i = 0; i < line.Length-1; i++) {\n\t\t\tif(method == \"gizmos\"){\n\t\t\t\tGizmos.DrawLine(line[i], line[i+1]);;\n\t\t\t}else if(method == \"handles\"){\n\t\t\t\tDebug.LogError(\"iTween Error: Drawing a line with Handles is temporarily disabled because of compatability issues with Unity 2.6!\");\n\t\t\t\t//UnityEditor.Handles.DrawLine(line[i], line[i+1]);\n\t\t\t}\n\t\t}\n\t}\t\t\n\t\n\tprivate static void DrawPathHelper(Vector3[] path, Color color, string method){\n\t\tVector3[] vector3s = PathControlPointGenerator(path);\n\t\t\n\t\t//Line Draw:\n\t\tVector3 prevPt = Interp(vector3s,0);\n\t\tGizmos.color=color;\n\t\tint SmoothAmount = path.Length*20;\n\t\tfor (int i = 1; i <= SmoothAmount; i++) {\n\t\t\tfloat pm = (float) i / SmoothAmount;\n\t\t\tVector3 currPt = Interp(vector3s,pm);\n\t\t\tif(method == \"gizmos\"){\n\t\t\t\tGizmos.DrawLine(currPt, prevPt);\n\t\t\t}else if(method == \"handles\"){\n\t\t\t\tDebug.LogError(\"iTween Error: Drawing a path with Handles is temporarily disabled because of compatability issues with Unity 2.6!\");\n\t\t\t\t//UnityEditor.Handles.DrawLine(currPt, prevPt);\n\t\t\t}\n\t\t\tprevPt = currPt;\n\t\t}\n\t}\t\n\t\n\tprivate static Vector3[] PathControlPointGenerator(Vector3[] path){\n\t\tVector3[] suppliedPath;\n\t\tVector3[] vector3s;\n\t\t\n\t\t//create and store path points:\n\t\tsuppliedPath = path;\n\n\t\t//populate calculate path;\n\t\tint offset = 2;\n\t\tvector3s = new Vector3[suppliedPath.Length+offset];\n\t\tArray.Copy(suppliedPath,0,vector3s,1,suppliedPath.Length);\n\t\t\n\t\t//populate start and end control points:\n\t\t//vector3s[0] = vector3s[1] - vector3s[2];\n\t\tvector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);\n\t\tvector3s[vector3s.Length-1] = vector3s[vector3s.Length-2] + (vector3s[vector3s.Length-2] - vector3s[vector3s.Length-3]);\n\t\t\n\t\t//is this a closed, continuous loop? yes? well then so let's make a continuous Catmull-Rom spline!\n\t\tif(vector3s[1] == vector3s[vector3s.Length-2]){\n\t\t\tVector3[] tmpLoopSpline = new Vector3[vector3s.Length];\n\t\t\tArray.Copy(vector3s,tmpLoopSpline,vector3s.Length);\n\t\t\ttmpLoopSpline[0]=tmpLoopSpline[tmpLoopSpline.Length-3];\n\t\t\ttmpLoopSpline[tmpLoopSpline.Length-1]=tmpLoopSpline[2];\n\t\t\tvector3s=new Vector3[tmpLoopSpline.Length];\n\t\t\tArray.Copy(tmpLoopSpline,vector3s,tmpLoopSpline.Length);\n\t\t}\t\n\t\t\n\t\treturn(vector3s);\n\t}\n\t\n\t//andeeee from the Unity forum's steller Catmull-Rom class ( http://forum.unity3d.com/viewtopic.php?p=218400#218400 ):\n\tprivate static Vector3 Interp(Vector3[] pts, float t){\n\t\tint numSections = pts.Length - 3;\n\t\tint currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);\n\t\tfloat u = t * (float) numSections - (float) currPt;\n\t\t\t\t\n\t\tVector3 a = pts[currPt];\n\t\tVector3 b = pts[currPt + 1];\n\t\tVector3 c = pts[currPt + 2];\n\t\tVector3 d = pts[currPt + 3];\n\t\t\n\t\treturn .5f * (\n\t\t\t(-a + 3f * b - 3f * c + d) * (u * u * u)\n\t\t\t+ (2f * a - 5f * b + 4f * c - d) * (u * u)\n\t\t\t+ (-a + c) * u\n\t\t\t+ 2f * b\n\t\t);\n\t}\t\n\t\t\n\t//andeeee from the Unity forum's steller Catmull-Rom class ( http://forum.unity3d.com/viewtopic.php?p=218400#218400 ):\n\tprivate class CRSpline {\n\t\tpublic Vector3[] pts;\n\t\t\n\t\tpublic CRSpline(params Vector3[] pts) {\n\t\t\tthis.pts = new Vector3[pts.Length];\n\t\t\tArray.Copy(pts, this.pts, pts.Length);\n\t\t}\n\t\t\n\t\t\n\t\tpublic Vector3 Interp(float t) {\n\t\t\tint numSections = pts.Length - 3;\n\t\t\tint currPt = Mathf.Min(Mathf.FloorToInt(t * (float) numSections), numSections - 1);\n\t\t\tfloat u = t * (float) numSections - (float) currPt;\n\t\t\tVector3 a = pts[currPt];\n\t\t\tVector3 b = pts[currPt + 1];\n\t\t\tVector3 c = pts[currPt + 2];\n\t\t\tVector3 d = pts[currPt + 3];\n\t\t\treturn .5f*((-a+3f*b-3f*c+d)*(u*u*u)+(2f*a-5f*b+4f*c-d)*(u*u)+(-a+c)*u+2f*b);\n\t\t}\t\n\t}\t\n\t\n\t//catalog new tween and add component phase of iTween:\n\tstatic void Launch(GameObject target, Hashtable args){\n\t\tif(!args.Contains(\"id\")){\n\t\t\targs[\"id\"] = GenerateID();\n\t\t}\n\t\tif(!args.Contains(\"target\")){\n\t\t\targs[\"target\"] = target;\n\t\t}\t\t\n\t\ttweens.Insert(0,args);\n\t\ttarget.AddComponent(\"iTween\");\n\t}\t\t\n\t\n\t//cast any accidentally supplied doubles and ints as floats as iTween only uses floats internally and unify parameter case:\n\tstatic Hashtable CleanArgs(Hashtable args){\n\t\tHashtable argsCopy = new Hashtable(args.Count);\n\t\tHashtable argsCaseUnified = new Hashtable(args.Count);\n\t\t\n\t\tforeach (DictionaryEntry item in args) {\n\t\t\targsCopy.Add(item.Key, item.Value);\n\t\t}\n\t\t\n\t\tforeach (DictionaryEntry item in argsCopy) {\n\t\t\tif(item.Value.GetType() == typeof(System.Int32)){\n\t\t\t\tint original = (int)item.Value;\n\t\t\t\tfloat casted = (float)original;\n\t\t\t\targs[item.Key] = casted;\n\t\t\t}\n\t\t\tif(item.Value.GetType() == typeof(System.Double)){\n\t\t\t\tdouble original = (double)item.Value;\n\t\t\t\tfloat casted = (float)original;\n\t\t\t\targs[item.Key] = casted;\n\t\t\t}\n\t\t}\t\n\t\t\n\t\t//unify parameter case:\n\t\tforeach (DictionaryEntry item in args) {\n\t\t\targsCaseUnified.Add(item.Key.ToString().ToLower(), item.Value);\n\t\t}\t\n\t\t\n\t\t//swap back case unification:\n\t\targs = argsCaseUnified;\n\t\t\t\t\n\t\treturn args;\n\t}\t\n\t\n\t//random ID generator:\n\tstatic string GenerateID(){\n\t\tint strlen = 15;\n\t\tchar[] chars = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8'};\n\t\tint num_chars = chars.Length - 1;\n\t\tstring randomChar = \"\";\n\t\tfor (int i = 0; i < strlen; i++) {\n\t\t\trandomChar += chars[(int)Mathf.Floor(UnityEngine.Random.Range(0,num_chars))];\n\t\t}\n\t\treturn randomChar;\n\t}\t\n\t\n\t//grab and set generic, neccesary iTween arguments:\n\tvoid RetrieveArgs(){\n\t\tforeach (Hashtable item in tweens) {\n\t\t\tif((GameObject)item[\"target\"] == gameObject){\n\t\t\t\ttweenArguments=item;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tid=(string)tweenArguments[\"id\"];\n\t\ttype=(string)tweenArguments[\"type\"];\n\t\t/* GFX47 MOD START */\n\t\t_name=(string)tweenArguments[\"name\"];\n\t\t/* GFX47 MOD END */\n\t\tmethod=(string)tweenArguments[\"method\"];\n               \n\t\tif(tweenArguments.Contains(\"time\")){\n\t\t\ttime=(float)tweenArguments[\"time\"];\n\t\t}else{\n\t\t\ttime=Defaults.time;\n\t\t}\n\t\t\t\n\t\t//do we need to use physics, is there a rigidbody?\n\t\tif(rigidbody != null){\n\t\t\tphysics=true;\n\t\t}\n               \n\t\tif(tweenArguments.Contains(\"delay\")){\n\t\t\tdelay=(float)tweenArguments[\"delay\"];\n\t\t}else{\n\t\t\tdelay=Defaults.delay;\n\t\t}\n\t\t\t\t\n\t\tif(tweenArguments.Contains(\"namedcolorvalue\")){\n\t\t\t//allows namedcolorvalue to be set as either an enum(C# friendly) or a string(JS friendly), string case usage doesn't matter to further increase usability:\n\t\t\tif(tweenArguments[\"namedcolorvalue\"].GetType() == typeof(NamedValueColor)){\n\t\t\t\tnamedcolorvalue=(NamedValueColor)tweenArguments[\"namedcolorvalue\"];\n\t\t\t}else{\n\t\t\t\ttry {\n\t\t\t\t\tnamedcolorvalue=(NamedValueColor)Enum.Parse(typeof(NamedValueColor),(string)tweenArguments[\"namedcolorvalue\"],true); \n\t\t\t\t} catch {\n\t\t\t\t\tDebug.LogWarning(\"iTween: Unsupported namedcolorvalue supplied! Default will be used.\");\n\t\t\t\t\tnamedcolorvalue = iTween.NamedValueColor._Color;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}else{\n\t\t\tnamedcolorvalue=Defaults.namedColorValue;\t\n\t\t}\t\n\t\t\n\t\tif(tweenArguments.Contains(\"looptype\")){\n\t\t\t//allows loopType to be set as either an enum(C# friendly) or a string(JS friendly), string case usage doesn't matter to further increase usability:\n\t\t\tif(tweenArguments[\"looptype\"].GetType() == typeof(LoopType)){\n\t\t\t\tloopType=(LoopType)tweenArguments[\"looptype\"];\n\t\t\t}else{\n\t\t\t\ttry {\n\t\t\t\t\tloopType=(LoopType)Enum.Parse(typeof(LoopType),(string)tweenArguments[\"looptype\"],true); \n\t\t\t\t} catch {\n\t\t\t\t\tDebug.LogWarning(\"iTween: Unsupported loopType supplied! Default will be used.\");\n\t\t\t\t\tloopType = iTween.LoopType.none;\t\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}else{\n\t\t\tloopType = iTween.LoopType.none;\t\n\t\t}\t\t\t\n         \n\t\tif(tweenArguments.Contains(\"easetype\")){\n\t\t\t//allows easeType to be set as either an enum(C# friendly) or a string(JS friendly), string case usage doesn't matter to further increase usability:\n\t\t\tif(tweenArguments[\"easetype\"].GetType() == typeof(EaseType)){\n\t\t\t\teaseType=(EaseType)tweenArguments[\"easetype\"];\n\t\t\t}else{\n\t\t\t\ttry {\n\t\t\t\t\teaseType=(EaseType)Enum.Parse(typeof(EaseType),(string)tweenArguments[\"easetype\"],true); \n\t\t\t\t} catch {\n\t\t\t\t\tDebug.LogWarning(\"iTween: Unsupported easeType supplied! Default will be used.\");\n\t\t\t\t\teaseType=Defaults.easeType;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\teaseType=Defaults.easeType;\n\t\t}\n\t\t\t\t\n\t\tif(tweenArguments.Contains(\"space\")){\n\t\t\t//allows space to be set as either an enum(C# friendly) or a string(JS friendly), string case usage doesn't matter to further increase usability:\n\t\t\tif(tweenArguments[\"space\"].GetType() == typeof(Space)){\n\t\t\t\tspace=(Space)tweenArguments[\"space\"];\n\t\t\t}else{\n\t\t\t\ttry {\n\t\t\t\t\tspace=(Space)Enum.Parse(typeof(Space),(string)tweenArguments[\"space\"],true); \t\n\t\t\t\t} catch {\n\t\t\t\t\tDebug.LogWarning(\"iTween: Unsupported space supplied! Default will be used.\");\n\t\t\t\t\tspace = Defaults.space;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}else{\n\t\t\tspace = Defaults.space;\n\t\t}\n\t\t\n\t\tif(tweenArguments.Contains(\"islocal\")){\n\t\t\tisLocal = (bool)tweenArguments[\"islocal\"];\n\t\t}else{\n\t\t\tisLocal = Defaults.isLocal;\n\t\t}\n\n        // Added by PressPlay\n        if (tweenArguments.Contains(\"ignoretimescale\"))\n        {\n            useRealTime = (bool)tweenArguments[\"ignoretimescale\"];\n        }\n        else\n        {\n            useRealTime = Defaults.useRealTime;\n        }\n\n\t\t//instantiates a cached ease equation reference:\n\t\tGetEasingFunction();\n\t}\t\n\t\n\t//instantiates a cached ease equation refrence:\n\tvoid GetEasingFunction(){\n\t\tswitch (easeType){\n\t\tcase EaseType.easeInQuad:\n\t\t\tease  = new EasingFunction(easeInQuad);\n\t\t\tbreak;\n\t\tcase EaseType.easeOutQuad:\n\t\t\tease = new EasingFunction(easeOutQuad);\n\t\t\tbreak;\n\t\tcase EaseType.easeInOutQuad:\n\t\t\tease = new EasingFunction(easeInOutQuad);\n\t\t\tbreak;\n\t\tcase EaseType.easeInCubic:\n\t\t\tease = new EasingFunction(easeInCubic);\n\t\t\tbreak;\n\t\tcase EaseType.easeOutCubic:\n\t\t\tease = new EasingFunction(easeOutCubic);\n\t\t\tbreak;\n\t\tcase EaseType.easeInOutCubic:\n\t\t\tease = new EasingFunction(easeInOutCubic);\n\t\t\tbreak;\n\t\tcase EaseType.easeInQuart:\n\t\t\tease = new EasingFunction(easeInQuart);\n\t\t\tbreak;\n\t\tcase EaseType.easeOutQuart:\n\t\t\tease = new EasingFunction(easeOutQuart);\n\t\t\tbreak;\n\t\tcase EaseType.easeInOutQuart:\n\t\t\tease = new EasingFunction(easeInOutQuart);\n\t\t\tbreak;\n\t\tcase EaseType.easeInQuint:\n\t\t\tease = new EasingFunction(easeInQuint);\n\t\t\tbreak;\n\t\tcase EaseType.easeOutQuint:\n\t\t\tease = new EasingFunction(easeOutQuint);\n\t\t\tbreak;\n\t\tcase EaseType.easeInOutQuint:\n\t\t\tease = new EasingFunction(easeInOutQuint);\n\t\t\tbreak;\n\t\tcase EaseType.easeInSine:\n\t\t\tease = new EasingFunction(easeInSine);\n\t\t\tbreak;\n\t\tcase EaseType.easeOutSine:\n\t\t\tease = new EasingFunction(easeOutSine);\n\t\t\tbreak;\n\t\tcase EaseType.easeInOutSine:\n\t\t\tease = new EasingFunction(easeInOutSine);\n\t\t\tbreak;\n\t\tcase EaseType.easeInExpo:\n\t\t\tease = new EasingFunction(easeInExpo);\n\t\t\tbreak;\n\t\tcase EaseType.easeOutExpo:\n\t\t\tease = new EasingFunction(easeOutExpo);\n\t\t\tbreak;\n\t\tcase EaseType.easeInOutExpo:\n\t\t\tease = new EasingFunction(easeInOutExpo);\n\t\t\tbreak;\n\t\tcase EaseType.easeInCirc:\n\t\t\tease = new EasingFunction(easeInCirc);\n\t\t\tbreak;\n\t\tcase EaseType.easeOutCirc:\n\t\t\tease = new EasingFunction(easeOutCirc);\n\t\t\tbreak;\n\t\tcase EaseType.easeInOutCirc:\n\t\t\tease = new EasingFunction(easeInOutCirc);\n\t\t\tbreak;\n\t\tcase EaseType.linear:\n\t\t\tease = new EasingFunction(linear);\n\t\t\tbreak;\n\t\tcase EaseType.spring:\n\t\t\tease = new EasingFunction(spring);\n\t\t\tbreak;\n\t\t/* GFX47 MOD START */\n\t\t/*case EaseType.bounce:\n\t\t\tease = new EasingFunction(bounce);\n\t\t\tbreak;*/\n\t\tcase EaseType.easeInBounce:\n\t\t\tease = new EasingFunction(easeInBounce);\n\t\t\tbreak;\n\t\tcase EaseType.easeOutBounce:\n\t\t\tease = new EasingFunction(easeOutBounce);\n\t\t\tbreak;\n\t\tcase EaseType.easeInOutBounce:\n\t\t\tease = new EasingFunction(easeInOutBounce);\n\t\t\tbreak;\n\t\t/* GFX47 MOD END */\n\t\tcase EaseType.easeInBack:\n\t\t\tease = new EasingFunction(easeInBack);\n\t\t\tbreak;\n\t\tcase EaseType.easeOutBack:\n\t\t\tease = new EasingFunction(easeOutBack);\n\t\t\tbreak;\n\t\tcase EaseType.easeInOutBack:\n\t\t\tease = new EasingFunction(easeInOutBack);\n\t\t\tbreak;\n\t\t/* GFX47 MOD START */\n\t\t/*case EaseType.elastic:\n\t\t\tease = new EasingFunction(elastic);\n\t\t\tbreak;*/\n\t\tcase EaseType.easeInElastic:\n\t\t\tease = new EasingFunction(easeInElastic);\n\t\t\tbreak;\n\t\tcase EaseType.easeOutElastic:\n\t\t\tease = new EasingFunction(easeOutElastic);\n\t\t\tbreak;\n\t\tcase EaseType.easeInOutElastic:\n\t\t\tease = new EasingFunction(easeInOutElastic);\n\t\t\tbreak;\n\t\t/* GFX47 MOD END */\n\t\t}\n\t}\n\t\n\t//calculate percentage of tween based on time:\n\tvoid UpdatePercentage(){\n\n        // Added by PressPlay   \n        if (useRealTime)\n        {\n            runningTime += (Time.realtimeSinceStartup - lastRealTime);      \n        }\n        else\n        {\n            runningTime += Time.deltaTime;\n        }\n\n\t\tif(reverse){\n\t\t\tpercentage = 1 - runningTime/time;\t\n\t\t}else{\n\t\t\tpercentage = runningTime/time;\t\n\t\t}\n\n        lastRealTime = Time.realtimeSinceStartup; // Added by PressPlay\n\t}\n\t\n\tvoid CallBack(string callbackType){\n\t\tif (tweenArguments.Contains(callbackType) && !tweenArguments.Contains(\"ischild\")) {\n\t\t\t//establish target:\n\t\t\tGameObject target;\n\t\t\tif (tweenArguments.Contains(callbackType+\"target\")) {\n\t\t\t\ttarget=(GameObject)tweenArguments[callbackType+\"target\"];\n\t\t\t}else{\n\t\t\t\ttarget=gameObject;\t\n\t\t\t}\n\t\t\t\n\t\t\t//throw an error if a string wasn't passed for callback:\n\t\t\tif (tweenArguments[callbackType].GetType() == typeof(System.String)) {\n\t\t\t\ttarget.SendMessage((string)tweenArguments[callbackType],(object)tweenArguments[callbackType+\"params\"],SendMessageOptions.DontRequireReceiver);\n\t\t\t}else{\n\t\t\t\tDebug.LogError(\"iTween Error: Callback method references must be passed as a String!\");\n\t\t\t\tDestroy (this);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid Dispose(){\n\t\tfor (int i = 0; i < tweens.Count; i++) {\n\t\t\tHashtable tweenEntry = (Hashtable)tweens[i];\n\t\t\tif ((string)tweenEntry[\"id\"] == id){\n\t\t\t\ttweens.RemoveAt(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDestroy(this);\n\t}\t\n\t\n\tvoid ConflictCheck(){//if a new iTween is about to run and is of the same type as an in progress iTween this will destroy the previous if the new one is NOT identical in every way or it will destroy the new iTween if they are:\t\n\t\tComponent[] tweens = GetComponents(typeof(iTween));\n\t\tforeach (iTween item in tweens) {\n\t\t\tif(item.type == \"value\"){\n\t\t\t\treturn;\n\t\t\t}else if(item.isRunning && item.type==type){\n\t\t\t\t//cancel out if this is a shake or punch variant:\n\t\t\t\tif (item.method != method) {\n\t\t\t\t\treturn;\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\t//step 1: check for length first since it's the fastest:\n\t\t\t\tif(item.tweenArguments.Count != tweenArguments.Count){\n\t\t\t\t\titem.Dispose();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//step 2: side-by-side check to figure out if this is an identical tween scenario to handle Update usages of iTween:\n\t\t\t\tforeach (DictionaryEntry currentProp in tweenArguments) {\n\t\t\t\t\tif(!item.tweenArguments.Contains(currentProp.Key)){\n\t\t\t\t\t\titem.Dispose();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(!item.tweenArguments[currentProp.Key].Equals(tweenArguments[currentProp.Key]) && (string)currentProp.Key != \"id\"){//if we aren't comparing ids and something isn't exactly the same replace the running iTween: \n\t\t\t\t\t\t\titem.Dispose();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//step 3: prevent a new iTween addition if it is identical to the currently running iTween\n\t\t\t\tDispose();\n\t\t\t\t//Destroy(this);\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid EnableKinematic(){\n\t\t/*\n\t\tif(gameObject.GetComponent(typeof(Rigidbody))){\n\t\t\tif(!rigidbody.isKinematic){\n\t\t\t\tkinematic=true;\n\t\t\t\trigidbody.isKinematic=true;\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n\t\n\tvoid DisableKinematic(){\n\t\t/*\n\t\tif(kinematic && rigidbody.isKinematic==true){\n\t\t\tkinematic=false;\n\t\t\trigidbody.isKinematic=false;\n\t\t}\n\t\t*/\n\t}\n\t\t\n\tvoid ResumeDelay(){\n\t\tStartCoroutine(\"TweenDelay\");\n\t}\t\n\t\n\t#endregion\t\n\t\n\t#region Easing Curves\n\t\n\tprivate float linear(float start, float end, float value){\n\t\treturn Mathf.Lerp(start, end, value);\n\t}\n\t\n\tprivate float clerp(float start, float end, float value){\n\t\tfloat min = 0.0f;\n\t\tfloat max = 360.0f;\n\t\tfloat half = Mathf.Abs((max - min) / 2.0f);\n\t\tfloat retval = 0.0f;\n\t\tfloat diff = 0.0f;\n\t\tif ((end - start) < -half){\n\t\t\tdiff = ((max - start) + end) * value;\n\t\t\tretval = start + diff;\n\t\t}else if ((end - start) > half){\n\t\t\tdiff = -((max - end) + start) * value;\n\t\t\tretval = start + diff;\n\t\t}else retval = start + (end - start) * value;\n\t\treturn retval;\n    }\n\n\tprivate float spring(float start, float end, float value){\n\t\tvalue = Mathf.Clamp01(value);\n\t\tvalue = (Mathf.Sin(value * Mathf.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + (1.2f * (1f - value)));\n\t\treturn start + (end - start) * value;\n\t}\n\n\tprivate float easeInQuad(float start, float end, float value){\n\t\tend -= start;\n\t\treturn end * value * value + start;\n\t}\n\n\tprivate float easeOutQuad(float start, float end, float value){\n\t\tend -= start;\n\t\treturn -end * value * (value - 2) + start;\n\t}\n\n\tprivate float easeInOutQuad(float start, float end, float value){\n\t\tvalue /= .5f;\n\t\tend -= start;\n\t\tif (value < 1) return end / 2 * value * value + start;\n\t\tvalue--;\n\t\treturn -end / 2 * (value * (value - 2) - 1) + start;\n\t}\n\n\tprivate float easeInCubic(float start, float end, float value){\n\t\tend -= start;\n\t\treturn end * value * value * value + start;\n\t}\n\n\tprivate float easeOutCubic(float start, float end, float value){\n\t\tvalue--;\n\t\tend -= start;\n\t\treturn end * (value * value * value + 1) + start;\n\t}\n\n\tprivate float easeInOutCubic(float start, float end, float value){\n\t\tvalue /= .5f;\n\t\tend -= start;\n\t\tif (value < 1) return end / 2 * value * value * value + start;\n\t\tvalue -= 2;\n\t\treturn end / 2 * (value * value * value + 2) + start;\n\t}\n\n\tprivate float easeInQuart(float start, float end, float value){\n\t\tend -= start;\n\t\treturn end * value * value * value * value + start;\n\t}\n\n\tprivate float easeOutQuart(float start, float end, float value){\n\t\tvalue--;\n\t\tend -= start;\n\t\treturn -end * (value * value * value * value - 1) + start;\n\t}\n\n\tprivate float easeInOutQuart(float start, float end, float value){\n\t\tvalue /= .5f;\n\t\tend -= start;\n\t\tif (value < 1) return end / 2 * value * value * value * value + start;\n\t\tvalue -= 2;\n\t\treturn -end / 2 * (value * value * value * value - 2) + start;\n\t}\n\n\tprivate float easeInQuint(float start, float end, float value){\n\t\tend -= start;\n\t\treturn end * value * value * value * value * value + start;\n\t}\n\n\tprivate float easeOutQuint(float start, float end, float value){\n\t\tvalue--;\n\t\tend -= start;\n\t\treturn end * (value * value * value * value * value + 1) + start;\n\t}\n\n\tprivate float easeInOutQuint(float start, float end, float value){\n\t\tvalue /= .5f;\n\t\tend -= start;\n\t\tif (value < 1) return end / 2 * value * value * value * value * value + start;\n\t\tvalue -= 2;\n\t\treturn end / 2 * (value * value * value * value * value + 2) + start;\n\t}\n\n\tprivate float easeInSine(float start, float end, float value){\n\t\tend -= start;\n\t\treturn -end * Mathf.Cos(value / 1 * (Mathf.PI / 2)) + end + start;\n\t}\n\n\tprivate float easeOutSine(float start, float end, float value){\n\t\tend -= start;\n\t\treturn end * Mathf.Sin(value / 1 * (Mathf.PI / 2)) + start;\n\t}\n\n\tprivate float easeInOutSine(float start, float end, float value){\n\t\tend -= start;\n\t\treturn -end / 2 * (Mathf.Cos(Mathf.PI * value / 1) - 1) + start;\n\t}\n\n\tprivate float easeInExpo(float start, float end, float value){\n\t\tend -= start;\n\t\treturn end * Mathf.Pow(2, 10 * (value / 1 - 1)) + start;\n\t}\n\n\tprivate float easeOutExpo(float start, float end, float value){\n\t\tend -= start;\n\t\treturn end * (-Mathf.Pow(2, -10 * value / 1) + 1) + start;\n\t}\n\n\tprivate float easeInOutExpo(float start, float end, float value){\n\t\tvalue /= .5f;\n\t\tend -= start;\n\t\tif (value < 1) return end / 2 * Mathf.Pow(2, 10 * (value - 1)) + start;\n\t\tvalue--;\n\t\treturn end / 2 * (-Mathf.Pow(2, -10 * value) + 2) + start;\n\t}\n\n\tprivate float easeInCirc(float start, float end, float value){\n\t\tend -= start;\n\t\treturn -end * (Mathf.Sqrt(1 - value * value) - 1) + start;\n\t}\n\n\tprivate float easeOutCirc(float start, float end, float value){\n\t\tvalue--;\n\t\tend -= start;\n\t\treturn end * Mathf.Sqrt(1 - value * value) + start;\n\t}\n\n\tprivate float easeInOutCirc(float start, float end, float value){\n\t\tvalue /= .5f;\n\t\tend -= start;\n\t\tif (value < 1) return -end / 2 * (Mathf.Sqrt(1 - value * value) - 1) + start;\n\t\tvalue -= 2;\n\t\treturn end / 2 * (Mathf.Sqrt(1 - value * value) + 1) + start;\n\t}\n\n\t/* GFX47 MOD START */\n\tprivate float easeInBounce(float start, float end, float value){\n\t\tend -= start;\n\t\tfloat d = 1f;\n\t\treturn end - easeOutBounce(0, end, d-value) + start;\n\t}\n\t/* GFX47 MOD END */\n\n\t/* GFX47 MOD START */\n\t//private float bounce(float start, float end, float value){\n\tprivate float easeOutBounce(float start, float end, float value){\n\t\tvalue /= 1f;\n\t\tend -= start;\n\t\tif (value < (1 / 2.75f)){\n\t\t\treturn end * (7.5625f * value * value) + start;\n\t\t}else if (value < (2 / 2.75f)){\n\t\t\tvalue -= (1.5f / 2.75f);\n\t\t\treturn end * (7.5625f * (value) * value + .75f) + start;\n\t\t}else if (value < (2.5 / 2.75)){\n\t\t\tvalue -= (2.25f / 2.75f);\n\t\t\treturn end * (7.5625f * (value) * value + .9375f) + start;\n\t\t}else{\n\t\t\tvalue -= (2.625f / 2.75f);\n\t\t\treturn end * (7.5625f * (value) * value + .984375f) + start;\n\t\t}\n\t}\n\t/* GFX47 MOD END */\n\n\t/* GFX47 MOD START */\n\tprivate float easeInOutBounce(float start, float end, float value){\n\t\tend -= start;\n\t\tfloat d = 1f;\n\t\tif (value < d/2) return easeInBounce(0, end, value*2) * 0.5f + start;\n\t\telse return easeOutBounce(0, end, value*2-d) * 0.5f + end*0.5f + start;\n\t}\n\t/* GFX47 MOD END */\n\n\tprivate float easeInBack(float start, float end, float value){\n\t\tend -= start;\n\t\tvalue /= 1;\n\t\tfloat s = 1.70158f;\n\t\treturn end * (value) * value * ((s + 1) * value - s) + start;\n\t}\n\n\tprivate float easeOutBack(float start, float end, float value){\n\t\tfloat s = 1.70158f;\n\t\tend -= start;\n\t\tvalue = (value / 1) - 1;\n\t\treturn end * ((value) * value * ((s + 1) * value + s) + 1) + start;\n\t}\n\n\tprivate float easeInOutBack(float start, float end, float value){\n\t\tfloat s = 1.70158f;\n\t\tend -= start;\n\t\tvalue /= .5f;\n\t\tif ((value) < 1){\n\t\t\ts *= (1.525f);\n\t\t\treturn end / 2 * (value * value * (((s) + 1) * value - s)) + start;\n\t\t}\n\t\tvalue -= 2;\n\t\ts *= (1.525f);\n\t\treturn end / 2 * ((value) * value * (((s) + 1) * value + s) + 2) + start;\n\t}\n\n\tprivate float punch(float amplitude, float value){\n\t\tfloat s = 9;\n\t\tif (value == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tif (value == 1){\n\t\t\treturn 0;\n\t\t}\n\t\tfloat period = 1 * 0.3f;\n\t\ts = period / (2 * Mathf.PI) * Mathf.Asin(0);\n\t\treturn (amplitude * Mathf.Pow(2, -10 * value) * Mathf.Sin((value * 1 - s) * (2 * Mathf.PI) / period));\n    }\n\t\n\t/* GFX47 MOD START */\n\tprivate float easeInElastic(float start, float end, float value){\n\t\tend -= start;\n\t\t\n\t\tfloat d = 1f;\n\t\tfloat p = d * .3f;\n\t\tfloat s = 0;\n\t\tfloat a = 0;\n\t\t\n\t\tif (value == 0) return start;\n\t\t\n\t\tif ((value /= d) == 1) return start + end;\n\t\t\n\t\tif (a == 0f || a < Mathf.Abs(end)){\n\t\t\ta = end;\n\t\t\ts = p / 4;\n\t\t\t}else{\n\t\t\ts = p / (2 * Mathf.PI) * Mathf.Asin(end / a);\n\t\t}\n\t\t\n\t\treturn -(a * Mathf.Pow(2, 10 * (value-=1)) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p)) + start;\n\t}\t\t\n\t/* GFX47 MOD END */\n\n\t/* GFX47 MOD START */\n\t//private float elastic(float start, float end, float value){\n\tprivate float easeOutElastic(float start, float end, float value){\n\t/* GFX47 MOD END */\n\t\t//Thank you to rafael.marteleto for fixing this as a port over from Pedro's UnityTween\n\t\tend -= start;\n\t\t\n\t\tfloat d = 1f;\n\t\tfloat p = d * .3f;\n\t\tfloat s = 0;\n\t\tfloat a = 0;\n\t\t\n\t\tif (value == 0) return start;\n\t\t\n\t\tif ((value /= d) == 1) return start + end;\n\t\t\n\t\tif (a == 0f || a < Mathf.Abs(end)){\n\t\t\ta = end;\n\t\t\ts = p / 4;\n\t\t\t}else{\n\t\t\ts = p / (2 * Mathf.PI) * Mathf.Asin(end / a);\n\t\t}\n\t\t\n\t\treturn (a * Mathf.Pow(2, -10 * value) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p) + end + start);\n\t}\t\t\n\t\n\t/* GFX47 MOD START */\n\tprivate float easeInOutElastic(float start, float end, float value){\n\t\tend -= start;\n\t\t\n\t\tfloat d = 1f;\n\t\tfloat p = d * .3f;\n\t\tfloat s = 0;\n\t\tfloat a = 0;\n\t\t\n\t\tif (value == 0) return start;\n\t\t\n\t\tif ((value /= d/2) == 2) return start + end;\n\t\t\n\t\tif (a == 0f || a < Mathf.Abs(end)){\n\t\t\ta = end;\n\t\t\ts = p / 4;\n\t\t\t}else{\n\t\t\ts = p / (2 * Mathf.PI) * Mathf.Asin(end / a);\n\t\t}\n\t\t\n\t\tif (value < 1) return -0.5f * (a * Mathf.Pow(2, 10 * (value-=1)) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p)) + start;\n\t\treturn a * Mathf.Pow(2, -10 * (value-=1)) * Mathf.Sin((value * d - s) * (2 * Mathf.PI) / p) * 0.5f + end + start;\n\t}\t\t\n\t/* GFX47 MOD END */\n\t\n\t#endregion\t\n\t\n\t#region Deprecated and Renamed\n\t/*\n\tpublic static void audioFrom(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: audioFrom() has been renamed to AudioFrom().\");}\n\tpublic static void audioTo(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: audioTo() has been renamed to AudioTo().\");}\n\tpublic static void colorFrom(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: colorFrom() has been renamed to ColorFrom().\");}\n\tpublic static void colorTo(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: colorTo() has been renamed to ColorTo().\");}\n\tpublic static void fadeFrom(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: fadeFrom() has been renamed to FadeFrom().\");}\n\tpublic static void fadeTo(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: fadeTo() has been renamed to FadeTo().\");}\n\tpublic static void lookFrom(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: lookFrom() has been renamed to LookFrom().\");}\n\tpublic static void lookFromWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: lookFromWorld() has been deprecated. Please investigate LookFrom().\");}\n\tpublic static void lookTo(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: lookTo() has been renamed to LookTo().\");}\n\tpublic static void lookToUpdate(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: lookToUpdate() has been renamed to LookUpdate().\");}\n\tpublic static void lookToUpdateWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: lookToUpdateWorld() has been deprecated. Please investigate LookUpdate().\");}\n\tpublic static void moveAdd(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveAdd() has been renamed to MoveAdd().\");}\n\tpublic static void moveAddWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveAddWorld() has been deprecated. Please investigate MoveAdd().\");}\n\tpublic static void moveBy(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveBy() has been renamed to MoveBy().\");}\n\tpublic static void moveByWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveAddWorld() has been deprecated. Please investigate MoveAdd().\");}\n\tpublic static void moveFrom(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveFrom() has been renamed to MoveFrom().\");}\n\tpublic static void moveFromWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveFromWorld() has been deprecated. Please investigate MoveFrom().\");}\n\tpublic static void moveTo(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveTo() has been renamed to MoveTo().\");}\n\tpublic static void moveToBezier(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveToBezier() has been deprecated. Please investigate MoveTo() and the \"path\" property.\");}\n\tpublic static void moveToBezierWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveToBezierWorld() has been deprecated. Please investigate MoveTo() and the \"path\" property.\");}\n\tpublic static void moveToUpdate(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveToUpdate() has been renamed to MoveUpdate().\");}\n\tpublic static void moveToUpdateWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveToUpdateWorld() has been deprecated. Please investigate MoveUpdate().\");}\n\tpublic static void moveToWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: moveToWorld() has been deprecated. Please investigate MoveTo().\");}\n\tpublic static void punchPosition(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: punchPosition() has been renamed to PunchPosition().\");}\n\tpublic static void punchPositionWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: punchPositionWorld() has been deprecated. Please investigate PunchPosition().\");}\t\n\tpublic static void punchRotation(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: punchPosition() has been renamed to PunchRotation().\");}\n\tpublic static void punchRotationWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: punchRotationWorld() has been deprecated. Please investigate PunchRotation().\");}\t\n\tpublic static void punchScale(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: punchScale() has been renamed to PunchScale().\");}\n\tpublic static void rotateAdd(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: rotateAdd() has been renamed to RotateAdd().\");}\n\tpublic static void rotateBy(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: rotateBy() has been renamed to RotateBy().\");}\n\tpublic static void rotateByWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: rotateByWorld() has been deprecated. Please investigate RotateBy().\");}\n\tpublic static void rotateFrom(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: rotateFrom() has been renamed to RotateFrom().\");}\n\tpublic static void rotateTo(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: rotateTo() has been renamed to RotateTo().\");}\n\tpublic static void scaleAdd(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: scaleAdd() has been renamed to ScaleAdd().\");}\n\tpublic static void scaleBy(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: scaleBy() has been renamed to ScaleBy().\");}\n\tpublic static void scaleFrom(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: scaleFrom() has been renamed to ScaleFrom().\");}\n\tpublic static void scaleTo(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: scaleTo() has been renamed to ScaleTo().\");}\n\tpublic static void shake(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: scale() has been deprecated. Please investigate ShakePosition(), ShakeRotation() and ShakeScale().\");}\n\tpublic static void shakeWorld(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: shakeWorld() has been deprecated. Please investigate ShakePosition(), ShakeRotation() and ShakeScale().\");}\n\tpublic static void stab(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: stab() has been renamed to Stab().\");}\n\tpublic static void stop(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: stop() has been renamed to Stop().\");}\n\tpublic static void stopType(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: stopType() has been deprecated. Please investigate Stop().\");}\n\tpublic static void tweenCount(GameObject target, Hashtable args){Debug.LogError(\"iTween Error: tweenCount() has been deprecated. Please investigate Count().\");}\n\t*/\n\t#endregion\n} \n","markers":{"markers":{"1":{"id":1,"range":[[50,20],[50,24]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":141,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/hisamatsu/_/dev/mcdonald-s-unity1/Assets/Scripts/plugin/iTween.cs","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"ae91ec330f1b4d2195c94f24e5e58e5469567491","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":141,"softTabs":false,"scrollTop":491,"scrollLeft":0,"displayBuffer":{"id":142,"softWrap":false,"editorWidthInChars":140,"tokenizedBuffer":{"bufferPath":"/Users/hisamatsu/_/dev/mcdonald-s-unity1/Assets/Scripts/plugin/iTween.cs","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":139,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":140,"softWrap":false,"editorWidthInChars":140,"tokenizedBuffer":{"bufferPath":"/Users/hisamatsu/_/dev/mcdonald-s-unity1/Assets/Scripts/character/BaseCharacterController.cs","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/hisamatsu/_/dev/mcdonald-s-unity1/Assets/Scripts/plugin/iTween.cs","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"command-logger":{"eventLog":{"project-find:show":{"count":1,"name":"project-find:show","lastRun":1400577379769},"project-find:show-in-current-directory":{"count":1,"name":"project-find:show-in-current-directory","lastRun":1400577408565}}},"find-and-replace":{"projectViewState":{"findHistory":["List"],"replaceHistory":[],"pathsHistory":["Assets/Scripts"],"modelState":{"useRegex":false,"caseSensitive":false}},"resultsModelState":{"useRegex":false,"caseSensitive":false}},"fuzzy-finder":{"/Users/hisamatsu/_/dev/mcdonald-s-unity1/Assets/Scripts/plugin/iTween.cs":1400584856607,"/Users/hisamatsu/_/dev/mcdonald-s-unity1/Assets/Scripts/character/BaseCharacterController.cs":1400577416716},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":7495921},"tree-view":{"directoryExpansionStates":{"Assets":{"Scripts":{}}},"selectedPath":"/Users/hisamatsu/_/dev/mcdonald-s-unity1/Assets/Scripts/plugin","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":446}}}